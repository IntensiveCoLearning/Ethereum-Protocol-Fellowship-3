---
timezone: Asia/Shanghai


---

# zhouCode

1. zhouCode，参加完一周前的协议学习，收获很多，这次继续狠狠地学习！
2. 你认为你会完成本次残酷学习吗？会
3. 你的联系方式（[zhouG1n](https://t.me/zhouG1n)）

# Notes

<!-- Content_START -->

## 2025.03.10

已知区块链有众多节点，每个节点都要保存完整的区块（理论上），但是每时每刻都在发生交易，这就导致每个节点实际上并不能真正的同时保存完全一致的内容，总会有一些节点先保存一部分数据。也就是**传播延迟**（propagation delay）

在POW时期，有可能出现2个矿工同时发现合法区块的情况，就会导致**暂时分叉**（temporal fork）一个称为主链，另一个称为叔父区块（uncles），叔父区块也会获得部分奖励。

POS机制中，新区块由投票决定，且区块的提议者由随机或者预先设定的调度机制选出，所以大大降低了多区块同时产生的可能性。由于只有一个指定的区块提议者负责出块，再加上更高效的共识和出块协调机制，网络中几乎不会出现由于传播延迟而导致的竞争性出块现象，因此也就没有了叔块的概念。

但是区块链的不确定性除了上述问题外还体现在并发交易的处理的不确定性。

**DApp**

**去中心化应用（DApp）** 一般由两部分组成：

- **用户看到的前端界面**（比如网页）；
- **后台运行的智能合约**（区块链上的程序）。

大多数 DApp（约 75%）的前端是用 JavaScript 写的网页，需要频繁和区块链网络交互。不过，由于前端本身不在链上，它需要通过 **以太坊节点** 提供的 **RPC 接口** 来和区块链沟通。

**举个实际例子**：
假设一个众筹 DApp 的前端想要显示用户的捐款记录，它会调用 `eth_getLogs` 方法获取数据；当用户发起新捐款时，前端则通过 `eth_sendTransaction` 方法提交交易，更新链上状态。

**但直接操作节点有两个大问题**：

1. **参数容易出错**：
   RPC 方法的参数格式很麻烦，比如要求「20 字节的十六进制地址」或「32 字节的十六进制字符串数组」，普通人很容易输错。
2. **没有实时通知功能**：
   区块链的交易确认时间不确定（比如可能几秒或几分钟），但节点不会主动通知前端「交易是否完成」。用户只能反复调用方法（比如不停查余额）才能知道结果，非常低效。

**所以实际开发中**，DApp 会用现成的 **JavaScript 工具库**（比如 ethers.js、web3.js）。这些工具做了两件事：

- 自动把参数转换成正确的格式（比如地址补全 0x 前缀）；
- 提供「回调通知」功能（比如交易成功后自动触发更新界面）。

前端（用户界面）在发起交易时，首先通过两个方法（`getAccounts`和`getTransactionCount`）获取两类信息：

1. **用户拥有的钱包地址**；
2. **该地址已完成的交易次数**（称为 `nonce`，类似交易流水号）。

接着，它会调用 `send` 方法向后台的 ERC20 智能合约发送一笔“铸造代币”的交易请求。如果交易成功，系统会返回一个交易凭证。

这里的关键点在于：**每次成功交易后，`nonce` 必须自动加 1**。如果 `nonce` 值错误（比如重复或跳过），可能导致交易被直接拒绝，或者长时间卡在等待状态。

但问题在于：用户可能无意中连接到不同的区块链节点服务（RPC 服务）。如果某个节点返回的 `nonce` 值不准确（比如比其他节点少 1），就会引发上述问题。这种情况下，即使代码逻辑正确，也会因为节点数据不同步而导致交易异常。

## 2025.03.11

**学习JSON-RPC**

每种[以太坊客户端](https://ethereum.org/zh/developers/docs/nodes-and-clients/#execution-clients)均实现了 [JSON-RPC 规范(opens in a new tab)](https://github.com/ethereum/execution-apis)，因而应用程序可以依赖一组统一的方法，而与具体节点或客户端实现无关。

[JSON-RPC(opens in a new tab)](https://www.jsonrpc.org/specification) 是一种无状态的、轻量级远程过程调用 (RPC) 协议。它定义了一些数据结构及其处理规则。它与传输无关，因为这些概念可以在同一进程，通过接口、超文本传输协议或许多不同的消息传递环境中使用。它使用 JSON (RFC 4627) 作为数据格式。

## 2025.03.12

### **Conventions**

JSON-RPC 使用 JSON，因此具有相同的类型系统（参见 http://www.json.org 或 RFC 4627）。JSON 可以表示四种基本类型（字符串、数字、布尔值和空值）以及两种结构化类型（对象和数组）。本规范中的“基本”一词指代这四种基本 JSON 类型中的任何一种。“结构化”一词指代这两种结构化 JSON 类型中的任何一种。当本文件提到任何 JSON 类型时，其首字母总是大写的：对象、数组、字符串、数字、布尔值、空值。真和假也大写。

所有客户端和服务器之间交换的成员名称，在考虑任何匹配时，应被视为大小写敏感。函数、方法和过程这些术语可以认为是可互换的。

客户端定义为请求对象的来源和响应对象的处理者。

服务器定义为响应对象的来源和请求对象的处理器。

本规范的某个实现可以轻松地同时扮演这两个角色，即使是对不同的客户端或相同的客户端。本规范不涉及这一层复杂性。

### **Request object**

一个 RPC 调用通过向服务器发送请求对象来表示。请求对象具有以下成员：

- JSON-RPC

  一个指定 JSON-RPC 协议版本的字符串。必须是“2.0”。

- 方法

  包含要调用的方法名称的字符串。以单词 rpc 开头后跟一个点字符（U+002E 或 ASCII 46）的方法名称保留用于 rpc-内部方法和扩展，不得用于其他任何用途。

- 参数

  结构化值，用于在调用方法期间持有要使用的参数值。此成员可以省略。

- id

  客户端建立的标识符，必须包含一个字符串、数字或（如果包含）NULL 值。如果不包含，则假定是一个通知。该值通常不应为 NULL，数字不应包含小数部分。

服务器必须以响应对象中包含的相同值进行回复。此成员用于关联两个对象之间的上下文。

不建议在请求对象中将 Null 用作 id 成员的值，因为本规范使用 Null 值表示具有未知 id 的响应。此外，由于 JSON-RPC 1.0 使用 Null 值作为通知的 id，这可能会在处理时造成混淆。

分数部分可能存在问题，因为许多十进制分数不能精确地表示为二进制分数。

#### 通知

通知是一个没有“id”成员的请求对象。表示通知的请求对象意味着客户端对相应的响应对象不感兴趣，因此不需要向客户端返回响应对象。服务器不得回复通知，包括那些在批量请求中的通知。

通知按定义是不可确认的，因为它们没有返回的响应对象。因此，客户端将不会意识到任何错误（例如“无效参数”、“内部错误”）。

#### 参数结构

如果存在，RPC 调用的参数必须以结构化值的形式提供。可以通过数组按位置或通过对象按名称提供。

- by-position: params 必须是一个数组，包含服务器期望的值顺序。
- by-name: params 必须是一个对象，其成员名称必须与服务器期望的参数名称匹配。缺少期望的名称可能会导致生成错误。名称必须完全匹配，包括大小写，以符合方法期望的参数。

### Response Object

当进行 RPC 调用时，服务器必须回复一个响应，除非是通知。响应以单个 JSON 对象的形式表达，具有以下成员：

- JSON-RPC

  一个指定 JSON-RPC 协议版本的字符串。必须是“2.0”。

- 结果

  此成员在成功时是必需的。 此成员必须在调用方法时发生错误的情况下不存在。 该成员的值由在服务器上调用的方法确定。

- 错误

  此成员在错误时是必需的。 此成员必须在调用过程中未触发错误的情况下不存在。 该成员的值必须是第 5.1 节中定义的对象。

- id

  此成员是必需的。 它必须与请求对象中 id 成员的值相同。 如果请求对象中检测到 ID 错误（例如解析错误/无效请求），它必须是空。

结果成员或错误成员必须包含其一，但不能同时包含两者。

### Error Object

当 RPC 调用遇到错误时，响应对象必须包含一个名为 error 的成员，其值是一个具有以下成员的对象：

- 代码

  一个表示发生错误类型的数字。 这是一个整数。

- 消息

  一个字符串，提供错误简短描述。 消息应限制为简洁的单句。

- 数据

  原始值或结构化值，包含有关错误的附加信息。  此内容可省略。 该成员的值由服务器定义（例如，详细错误信息、嵌套错误等）。

错误代码从-32768 到-32000 是保留用于预定义错误的。在此范围内但未在以下内容中明确定义的任何代码，保留供将来使用。错误代码几乎与以下网址建议的 XML-RPC 相同：[http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php](http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php)

| 代码             | 消息       | 含义                                                     |
| :--------------- | :--------- | :------------------------------------------------------- |
| -32700           | 解析错误   | 服务器收到无效的 JSON。 服务器解析 JSON 文本时发生错误。 |
| -32600           | 无效请求   | 发送的 JSON 不是一个有效的请求对象。                     |
| -32601           | 方法未找到 | 方法不存在/不可用。                                      |
| -32602           | 无效的参数 | 无效的方法参数。                                         |
| -32603           | 内部错误   | 内部 JSON-RPC 错误。                                     |
| -32000 至 -32099 | 服务器错误 | 保留供实现定义的服务器错误使用。                         |

剩余空间可用于应用定义的错误。

## 2025.03.13

以太坊中使用RPC主要通过Web3.js或者ethers.js等库，其内置了JSON-RPC的调用

例如，通过调用 `web3.eth.getBalance(address)` 就可以查询某个地址的余额，而不需要手动构造 JSON 请求。

### RPC 使用流程

下面以一个典型 DApp 前端调用 RPC 的流程为例：

1. **选择 RPC 服务提供商**

   - 可以使用自己运行的以太坊节点（例如 geth 或 openethereum），也可以使用第三方提供的服务（如 Infura、Alchemy 等）。这些服务提供一个可访问的节点 URL。
   - DApp 配置中会指定这个 RPC 端点，通常是一个 HTTPS 或 WebSocket 地址。

2. **建立连接**

   - 前端（或后端）通过 RPC 库（如 Web3.js 或 ethers.js）与指定的节点建立连接。

   - 例如，在 Web3.js 中：

     ```
     js复制编辑const Web3 = require('web3');
     const web3 = new Web3('https://mainnet.infura.io/v3/YOUR-PROJECT-ID');
     ```

3. **查询数据**

   - 通过调用 RPC 方法查询区块链数据：
     - 查询余额：`web3.eth.getBalance(address)`
     - 查询交易信息：`web3.eth.getTransaction(txHash)`
     - 获取当前区块号：`web3.eth.getBlockNumber()`
   - 这些调用底层都会构造一个 JSON-RPC 请求并发送给节点，然后节点返回相应的数据。

4. **发送交易**

   - 当用户需要执行某个状态变更（例如转账或调用智能合约）时：
     - 前端构造一笔交易，包括：发送地址、接收地址、gas 限额、gas 价格、数据（如果调用合约方法）等。
     - 用户使用钱包（如 MetaMask）或本地私钥对交易进行签名。
     - 签名后的交易通过 RPC 方法（例如 `eth_sendRawTransaction`）发送到节点。
     - 节点验证交易签名和其他参数，将交易广播到整个网络。

5. **监听事件与结果确认**

   - DApp 还可以通过 RPC 订阅机制（例如使用 WebSocket 订阅 `logs` 或 `newHeads`）来监听智能合约事件或新区块的生成，从而对用户的操作给予反馈。

   - 例如，使用 ethers.js 监听合约事件：

     ```javascript
     contract.on("Transfer", (from, to, value, event) => {
         console.log(`Transfer from ${from} to ${to} of ${value}`);
     });
     ```

### 小结

- **抽象化库的作用**：像 Web3.js 和 ethers.js 将 JSON-RPC 的繁琐细节封装起来，开发者只需要调用库函数即可实现查询、提交交易、监听事件等操作。
- **钱包的整合**：大部分 DApp 都集成了钱包（例如 MetaMask），它会负责管理用户的私钥、签名交易以及连接到 RPC 端点，简化了前端开发。
- **安全性与性能**：使用稳定的第三方 RPC 服务可以提高访问速度和稳定性，但也需要注意服务的安全性和去中心化程度，确保数据来源可靠。

## 2025.03.16

不能再摆烂了

认识EIPs（[Ethereum Improvement Proposals](https://eips.ethereum.org/)）

EIP 是一份设计文档，为以太坊社区提供信息，或描述以太坊的新功能或其流程或环境。EIP 应提供该功能的简洁技术规范和理由。EIP 作者负责在社区内达成共识并记录不同意见。

EIPs核心升级，来自[Core | Ethereum Improvement Proposals](https://eips.ethereum.org/core)——共61个，未来很长一段时间研究下这个，帮助我理解以太坊发展至今经历了什么。

**EIPs-2：**家园硬分叉（Homestead hard-fork）

**主要内容**

1. **合约创建成本上调**：为了防止人们以低成本创建合约进行以太币转账，Homestead 更新将创建合约的成本从 21,000 提高到 53,000。这有助于平衡网络资源的使用，并减少滥用的可能性。
2. **规范化交易签名**：为了避免交易签名的歧义，Homestead 更新要求交易的 s 值必须小于或等于 `secp256k1n/2`。这确保了每笔交易的签名只有一个有效版本，从而提高了交易的安全性和可追溯性。
3. **合约创建失败的逻辑优化**：在 Homestead 之前，如果创建合约时汽油不足，会产生一个空合约。更新后，如果汽油不足，合约将不会被创建，这样可以清晰地区分成功和失败的结果，并在失败时保护用户资金。
4. **难度调整算法优化**：Homestead 更新修改了难度调整算法，以防止矿工操纵区块时间戳，确保网络难度的稳定性，并保持区块生成的均衡性和网络安全。

**EIPs-5**：`RETURN` 和 `CALL*` 的 Gas 使用

**动机**

1. **问题发现**：在以太坊虚拟机中，当一个合约调用另一个合约的函数时，需要预先指定返回数据的大小，这限制了处理动态数据的能力，并且可能导致内存浪费和Gas费用增加。
2. **成本和灵活性问题**：如果预留的内存空间过大，将会支付未使用内存的Gas费用，导致成本增加；如果预留的空间不足，将无法返回完整的数据，影响灵活性。
3. **动态数据处理困难**：由于无法预知调用结果的确切大小，合约开发者在处理动态数据时面临挑战，这限制了智能合约的功能和应用场景。

**解决**

1. **降低成本**：通过 EIP-5，只有当 `CALL*` 操作码执行完毕并实际写入内存时，才会收取Gas费用，从而减少了不必要的内存分配和Gas消耗。
2. **提高灵活性**：合约开发者可以预留一个足够大的内存区域，而只为实际使用的部分支付Gas费用，这样可以更灵活地处理任意大小的返回数据。
3. **简化合约编写**：开发者不再需要精确计算返回数据的大小，可以通过 `MSIZE` 操作码动态确定实际写入的内存区域，简化了智能合约的编写过程。
4. **促进动态数据的使用**：EIP-5 鼓励了在智能合约中使用动态数据类型，如字符串和动态数组，因为它们可以更高效地被处理和返回。
5. **保持向后兼容性**：EIP-5 的实施对现有合约的影响很小，不会使用更多的Gas，并且对于内存大小的变化，合约应该是可重定位的，不会导致现有合约的错误或漏洞。
6. **实施难度较低**：对以太坊虚拟机的更改是最小化的，VM 实现者需要在调用结束后，且有足够的Gas后才扩展内存，这样可以避免潜在的Gas不足问题，同时确保了兼容性和安全性。

## 2025.03.17

**EIPs-7**：`DELEGATECALL` 操作码

在以太坊智能合约的早期版本中，开发者希望能够创建代理合约，这种合约可以将交易的执行代理给另一个合约，同时保持交易的发起人和金额信息不变。这样的功能对于合约的升级和模块化设计非常重要，但在 `DELEGATECALL` 之前，并没有一个标准的方式来实现这一点。

**改进**：

1. **代理合约的实现变得简单**：通过引入 `DELEGATECALL` 操作码，开发者可以更容易地创建代理合约，这种合约可以调用其他合约的代码，同时保持原始交易的发起人和金额信息。这使得合约的升级和维护变得更加灵活。(更好地复用已有合约)
2. **提高了合约的可扩展性**：合约可以通过 `DELEGATECALL` 调用外部合约中的函数，这样可以在不修改原有合约代码的情况下，扩展合约的功能。（提高合约可扩展性）
3. **超越Gas限制**：在以太坊中，每笔交易都有一个Gas限制，即执行交易可以消耗的最大计算资源量。`DELEGATECALL` 允许合约在不同的执行环境之间分配Gas，这样可以执行更复杂的操作，甚至超越单次交易的Gas限制。
4. **安全性和灵活性的平升**：`DELEGATECALL` 提供了一种标准化的方法来处理合约之间的代理调用，这有助于提高合约的安全性，并为开发者提供了更多的灵活性来设计合约的架构。
5. **减少了代码重复**：通过 `DELEGATECALL`，合约可以重用其他合约的代码，减少了代码的重复编写，使得合约的开发更加高效。

**EIPs-100**：Change difficulty adjustment to target mean block time including uncles

EIP-100 提议改变以太坊的难度调整机制，以确保平均区块时间（包括叔块）达到目标，从而保证发行率的可预测性和不可操纵性。

由于此内容基于POW，所以就不细看了

**EIPs-140**：REVERT instruction

EIP-140 提案引入了一个新的 EVM 指令 `REVERT`，用于在合约执行过程中终止执行并回滚状态变化，同时返回一个错误信息。

1. **`REVERT` 指令的引入提供了一种新的错误处理机制**，允许在智能合约执行时，以一种可控的方式终止执行并回滚状态变化。
2. 与 `THROW` 指令不同，`REVERT` 在执行失败时不会消耗发送者的 gas，这有助于减少不必要的 gas 消耗。
3. `REVERT` 指令允许开发者指定一个错误信息，这可以帮助开发者更准确地定位和解决合约执行失败的问题。
4. 通过使用 `REVERT` 指令，可以提高智能合约的健壮性和安全性，减少因错误处理不当而导致的合约漏洞。
5. 该提案的实施有助于提升以太坊网络的整体效率和用户体验。

## 2025.03.20

**EIP-141**：

指定一个 EVM 指令作为无效指令，以便在需要中断执行时提供一个明确的原因。具体来说，opcode `0xfe` 被定义为 `INVALID` 指令，用于终止执行。这个指令在过去没有被使用，因此对现有合约不会产生影响。

**EIP-145**：加入位运算指令

EIP-145 旨在通过引入三条新的指令来增强 EVM 的功能，这些指令分别是左移（SHL）、逻辑右移（SHR）和算术右移（SAR）。这些指令的引入使得 EVM 能够以更高效的方式处理位运算，并且相比于使用算术运算符实现的位移操作，它们的使用成本更低。新指令的成本设定为 3 个Gas，属于非常低的费用等级。

**EIP-150**：IO 密集型操作的费用变更

针对 IO 密集型操作，如 EXTCODESIZE、EXTCODECOPY、BALANCE、SLOAD、CALL、DELEGATECALL、CALLCODE 和 SELFDESTRUCT，增加了Gas成本，以反映它们相对于其他操作码的实际成本。这有助于防止通过事务垃圾邮件攻击网络性能。

如果调用请求的Gas超过了允许的最大值，将不会返回 OOG（Out Of Gas）错误，而是会使用 “所有除一个 64 分之之外” 的Gas量进行调用。这有助于减少调用堆栈深度攻击的风险。

## 2025.03.21

**EIP-152**：添加 BLAKE2 压缩函数`F`预编译

EIP-152 提议在以太坊虚拟机中添加 BLAKE2 哈希算法的压缩函数 `F` 的预编译合约，以便更低成本地运行 BLAKE2b 哈希函数及其变体，促进以太坊与 Zcash 等区块链之间的互操作性。

**EIP-155**：简单的重放攻击防护

EIP-155 提出了一种简单的重放攻击保护机制，通过在交易哈希计算中加入链 ID 来区分不同网络的交易，从而防止在不同的以太坊链上重放交易。

**EIP-158**：状态清除

EIP-158（状态清理）是一个标准追踪的核心改进提案，由 Vitalik Buterin 提出。该提案的主要目的是在区块链上清理无用的空账户，以减少状态的大小和提高同步速度。

**EIP-160**：EXP指令费用增加

EIP-160 提议在以太坊的特定硬分叉点（Spurious Dragon）增加 EXP 操作码的 gas 成本。

## 2025.03.22

**EIP-161**：状态 trie 清理（保持不变性替代方案）

EIP-161 提出了一种清理以太坊状态三叉 kov 树的方法，以保持不变量，该方法在 Sp Fork Spurious Dragon 中实施。

问题：在以太坊网络中，每个账户都有一个状态，这个状态包括了账户的余额、非 ces（用于确定下一个可用的交易号号）和存储的数据。随着时间的推移，网络中会出现很多空账户，即这些账户没有余额、没有存储的数据，也没有代码。这些空账户占用了状态三叉 kov 树的空间，这是一个数据结构，用于存储和检索以太坊网络中的账户信息。随着空账户的增多，状态三叉 kov 树变得越来越大，这不仅占用了更多的存储空间，还可能导致网络运行效率降低。

解决：EIP-161 提案旨在解决这个问题。它通过在交易结束时自动删除任何在交易过程中被触及但最终变成空的账户。这样做的好处是：

1. **网络效率**：通过删除无用的空账户，减少了状态三叉 kov 树的大小，从而提高了整个网络的效率。
2. **状态清理**：这个提案不仅仅是删除账户，它还规定了一些具体的情况，比如在账户创建时如何处理非 ces，以及在执行`CALL`和`SUICIDE`操作时如何收取费用。
3. **避免边缘情况**：EIP-161 确保了在交易执行过程中，账户的状态变化不会导致一些奇怪的情况，比如账户在执行过程中消失，然后又突然出现。
4. **安全性**：提案确保了即使在交易失败（比如因为 gas 不足）时，空账户的删除也能被回滚，这样可以防止不必要的状态变化，保护网络的安全性。

简单来说，EIP-161 就像是一项网络清理计划，它帮助以太坊网络保持整洁，提高效率，同时确保了在清理过程中网络的安全性和一致性。

**EIP-170**： 为合约代码设定了大小限制，以防止潜在的拒绝服务攻击（DoS）

EIP-170 引入了硬分叉（Hard Fork），并在规范中明确指定了 `MAX_CODE_SIZE`（`0x6000`，即 `2**14 + 2**13`）和 `FORK_BLKNUM`（2,675,000）两个关键参数，以及 `CHAIN_ID`（1，即主网）。当区块号码大于等于 `FORK_BLKNUM` 时，如果合约初始化数据的长度超过 `MAX_CODE_SIZE` 字节，则合约创建将失败，并出现出错。这个提案的理由在于，尽管当前的气价限能力可以接受，但在未来可能会有更高的气限制，而这可能会导致读取代码、处理代码和验证区块的合计成本变得非常高。因此，通过在合约代码的大小上设置硬限制，可以防止这种情况的发生。

**EIP-196**：提出了两个预编译合约，用于实现椭圆曲线 alt_bn128 上的加法和标量乘法操作

EIP-196 涉及两个预编译合约的提案，这些合约允许在区块链上直接进行椭圆曲线 alt_bn128 的加法和标量乘法操作。这些操作通过预编译合约直接执行，减少了编 atic 脚本的复杂性和执行时间。这两个预编译合约分别是：

- 加法预编译合约：用于计算两点的椭圆曲线加法。
- 标量乘法预编译合约：用于计算点的标量乘法，即一个点的连续加法操作。

这些预编译合约的引入将有助于简化智能合约开发，提高涉及椭圆曲线运算的交易的效率。

**EIP-197**：提议增加预编译合约以支持 zkSNARKs 验证，通过优化对称二次元曲线上的优化前乘（pairing）检查，以便在区块链气体限制内进行高效的操作。

和零知识验证相关，不细扣细节了

**EIP-198**：提出了一种大整数模指数运算的标准，以在以太坊中有效地执行此类运算

定义了一系列参数和规则，用于处理大数的模指数运算，并详细说明了如何计算所需的气体费用。此外，提案还讨论了如何通过这种方式在 EVM 中高效地进行 RSA 验证和其他数论密码学应用。

## 2025.03.23

**EIP-211**：新增操作码：RETURNDATASIZE 和 RETURNDATACOPY

长期以来一直有人请求在 EVM 内部允许返回任意长度的数据。现有的提案总是与计费非常复杂的气费问题相关。本提案解决了相同的问题，同时它具有非常简单的气费计费机制，并且只需要对调用操作码进行最小更改。其工作原理与现有的 calldata 处理方式非常相似；调用后，返回数据被保存在一个虚拟缓冲区中，调用者可以从该缓冲区中复制（或部分复制）到内存中。在下一次调用时，缓冲区将被覆盖。此机制 100%向后兼容。

**EIP-214**：新的操作码 STATICCALL

增加了一个新的操作码，可用于调用另一个合约（或自身），同时在调用期间（及其子调用，如果存在）禁止对状态的任何修改。任何尝试执行此类修改的操作码（详情见下文）将引发异常，而不是执行修改。

**EIP-225**：Clique 权威证明共识协议

EIP-225 描述了基于权威的共识协议 Clique，它是为了解决以太坊测试网（Rinkeby）中的共识问题而设计的。该协议简单易于实现，允许在任何现有的以太坊客户端中嵌入，同时保持对现有同步技术的支持。

Clique 协议通过在区块头中使用签名和投票机制来维护一个动态更新的授权签名者列表。该协议允许在不改变区块链基础设施的情况下进行更新和维护。

## 2025.03.24

**EIP-649**：Metropolis 难度炸弹延迟和区块奖励减少

该提议通过使用一个虚假的区块编号来计算难度，使得难度炸弹效果在 300 万区块后才开始生效，同时将基础区块奖励调整为 3 个以太币。此外，叔叔和侄子（节点）奖励也相应地调整以保持以太币的持续发行量。这一改变旨在确保链上的可持续性，并为即将到来的权益证明（Proof-of-Stake, PoS）做准备。（原来17年就准备POS了）

**EIP-658**：在收据中嵌入交易状态码

该提案要求的 EIP-140，提出了一个替代方案，即在回执中嵌入状态码来代替中间状态根，以此来指示交易是否成功。这一改变允许用户在事务中明确地知道交易是否成功，同时也解决了由于 EIP-98 的废弃而导致的回执中缺少返回数据的问题。

这构成了一个最小的可能更改，允许获取事务的成功/失败状态，同时保留现有功能，对 Metropolis 造成最小干扰或额外工作。

**EIP-684**：发生冲突时撤销创建，如果地址已有代码则撤销合约创建

在合约创建时，如果目标地址已经存在代码（即 nonce 不为零或代码长度不为零），应该回滚交易，作为对潜在冲突的反应。该提议旨在防止一种攻击，该攻击通过在已有代码的地址上 “创建” 合约来随意更改代码。

## 2025.03.25

**EIP-1014**：瘦身 CREATE2

通过添加一个新的操作码 `CREATE2`（`0xf5`），使得合约可以在一个新的地址上初始化，而这个地址是通过一种特殊的哈希算法得到的，该算法包括地地址、盐（salt）和初始化代码（init_code）的哈希。这个提案还规定了操作码的 gas 消耗规则，以及如何处理地址碰撞等问题。

**EIP-1052**：EXTCODEHASH 操作码

新的 opcode `EXTCODEHASH`（opcode 0x3f），用于返回合约代码的 keccak256 哈希值，帮助合约在不需要整个字节码的情况下验证合约的实现。这个 opcode 对于区分没有代码的账户和不存在的账户非常有用，它使得智能合约可以检查账户是否存在。新的 opcode `EXTCODEHASH` 的 gas 成本与 `BALANCE` 相同，为 400。

## 2025.03.26

**EIP-1108**：降低 alt_bn128 预编译的 gas 成本

EIP-1108 提议减少 alt_bn128 预编译的汽油成本，这是基于 Go 参考实现和 Parity 客户端的性能改进。该提案更新了 ECADD 和 ECMUL 的成本，并对配对检查的成本进行了更新。通过降低这些预编 iale 的成本，EIP-1108 使用了一个更公平的价格，这取决于 Parity 客户端的性能。这一变化可能会显著降低 AZTEC、Rollup、Ignis、ZEther 等协议的成本，并使 zk-SNARK 验证更加经济。EIP-1108 的提出者认为，通过降低 bn128 预编译的汽油成本，可以更好地反映它在网络上的计算负载，并为 Ethereum 的隐私和扩展解决方案增加更多的用例。

一句话锐评：Go也有这个椭圆曲线！实现的还更好！学就完事了

**EIP-1153**：瞬态存储操作码

EIP-1153: Transient storage opcodes 提出了两个新的 EVM 操作码 `TLOAD` 和 `TSTORE`，它们允许在单独事务中使用的临时存储空间，这个空间的数据在事务结束时会被丢弃，而且它不需要像 `SSTORE` 和 `SLOAD` 那样的气 Price rebate（气价回退）。这两个操作码允许更高效的在帧之间通信，同时降低了成本。

一句话锐评：两个新的操作码，允许使用临时存储空间，高效的通信。太底层了，不好锐评

**EIP-1234**：君士坦丁堡难度炸弹延迟和区块奖励调整

EIP-1234 的核心内容是通过推迟难度炸弹和调整区块奖励，以维持以太坊生态系统的稳定性。这一变动通过在计算难度时使用假设的区块号来实现，目的是推迟难度炸弹12个月。此外，区块奖励从原有的奖励结构调整为固定的2 ETH，同时调整了叔伯和外甥的奖励。这一变动旨在应对 Casper 开发和转向权益证明的延迟，以及确保区块奖励的持续稳定性。

一句话锐评：变革太大，整个链还没有准备好，就先推迟了

**EIP-1283**：SSTORE 无脏映射的Gas网计费

EIP-1283 旨在优化以太坊虚拟机中的 SSTORE 操作，通过实施新的 gas 计算方法，消除了传统的脏映射（dirty maps）的需求。这一变化减少了存储写入操作的 gas 消耗，并通智能合约的执行提供了更细粒度的 gas 计量。该提案详细说明了 SSTORE 操作的 gas 消耗计算，以及如何通过新的方式减少网络负担和提高效率。

一句话锐评：这个又开始替代1153的方案了，Gas计费方式一直在优化

## 2025.03.28

**EIP-1344**：链 ID 操作码

EIP-1344 为智能合约添加了一个新的操作码 `CHAINID`，允许在区块链上获取当前链的唯一标识符。通过在智能合约中获取链 ID，可以有效地防止跨链的重放攻击。

一句话锐评：什么？这个之前居然没有吗！

**EIP-1559**：ETH 1.0 链的费率市场变更

EIP-1559 是一个旨在改变以太坊区块链手续费市场的提案，引入了一种新的交易手续费制度，包括基础费用和优先费用，以及随机燃气（gas）的增减和减少，以应对网络拥堵。

一句话锐评：有钱先办业务，优先费。

## 2025.03.29

**EIP-1884**：基于 trie 大小依赖的指令重定价

EIP-1884 提案于 2019 年 3 月 28 日创建，提出对某些 opcode 进行重新定价，以反映它们在资源消耗上的真实成本。这通提案要求 EIP-150 和 EIP-1052 的实施。本提案特别是对于 SLOAD、BALANCE 和 EXTCODEHASH 等操作码的 gasCost 进行了调整。此外，提案还引入了新的 opcode—SELFBALANCE，用于检查当前地址的余额。为了保持区块链的稳定性和安全性，本提案还进行了一系列的测试用例，以确保新的 gasCost 的准确性和实用性。

一句话锐评：V神也是人，缝缝补补也正常。有的OP码收费过低了

**EIP-2028**：交易数据燃气成本降低

EIP-2028 旨在通过减少 Calldata 的气价来提高网络的可扩展性和安全性。作者们提出了这一改变，以减少每字节的气价，从而减少了数据传输时的网络延迟。该提案基于 Sompolinsky 和 Zohar 以及 Pass、Seeman 和 Shelat 关于网络延迟与安全性关系的数学模型，并通过实验验证模型的准确性。此外，该提案还考虑了 Layer two 解决方案和无状态客户端的气价变化，以及对网络延迟的响的评估。该提案还包括了对 Calldata 气价减少对网络延迟和效率的影响的实验测试，以及对 ParityGeth 参考实现的引用。

一句话锐评：为啥减少气价就可以减少传输延迟？因为气价就是算力的体现，而且这个值是人为设定的（至少现在看到EIP2028是这样），所以减少气价就可以让单位时间执行的动作更多，自然就减少延迟了。

## 2025.03.30

**EIP-2200**：网络燃气计量结构化定义

EIP-2200 为 `SSTORE` opcode 引入了结构化的净气费定义，以实现净气计量，优化存储和减少不必要的气体消耗，同时保持与现有实现的兼容性。该提案通过将 `SSTORE` opcode 的气体成本计算方式从 `200` 调整到 `800`，并引入了 `SLOAD_GAS`、`SSTORE_SET_GAS`、`SSTORE_RESET_GAS` 和 `SSTORE_CLEARS_SCHEDULE` 变量来定义新的气体成本结构。

一句话锐评：还是优化gas计费方式，包括修改旧的计费和增加新的变量。

**EIP-2384**：Muir Glacier 难度炸弹延迟

EIP-2384 提议推迟以太坊中的难度炸弹（difficulty bomb）效应，以减缓区块产生的速度，防止网络变得过于昂贵和缓慢。

一句话锐评：又双叒叕推迟了，我推测他要推迟到2021年（maybe）

**EIP-2565**: 模幂运算 Gas 成本

EIP-2565 要求在指定的区块高度（FORK_BLOCK_NUMBER）后，调用位于地址 `0x0000000000000000000000000000000000000005` 的 `ModExp` 预编译时，根据新的算法计算气体成本。该算法考虑了多项式的计算复杂性和指数的位长度，以及迭代次数，并设置了一个最小气体成本以防止滥用。

一句话锐评：以前计算复杂度的算法落伍了，更新算法后更合理了，幂运算花费会小一点（或者更合理）

## 2025.03.31

**EIP-2681**：限制账户 nonce 为 2^64-1

将账户 Nonce 的最大值限制为 `2^64-1`，以防止整数溢出问题。当前状态中没有任何账户的 nonce 会超过该值。截至 2020 年 11 月，账户 `0xea674fdde714fd979de3edf0f56aa9716b898ec8` 负责的最高账户 nonce 约为 2900 万。

一句话锐评：典中典之防止整数溢出

**EIP-2718**：类型化交易信封

定义了一种新的交易类型，该类型是未来交易类型的信封。该交易类型允许在保持向后兼容性的同时，为未来的交易类型定义一个统一的格式。该格式要求所有新的交易类型在其签名数据的第一个字节中包含交易类型标识符，以避免签名重用问题。此外，该标准保留了 0x7f 以内的交易类型标识符，为未来的扩展留下了空间。

一句话锐评：不好锐评

## 2025.04.03

**EIP-2929**：状态访问操作码的 Gas 费用增加

EIP-2929 提案旨在通过增加首次在交易中使用的相关操作码的 Gas 费用，来防止滥用存储访问操作码导致的网络攻击。\

一句话锐评：以太坊也避免不了Dos攻击啊

**EIP-2930**：可选访问列表

EIP-2930 旨在通过引入一个新的交易类型来减轻 EIP-2929 带来的合约破坏风险，该交易类型允许交易预先指定并支付计划访问的账户和存储槽位。该交易类型要求额外的 gas 费用，但比访问列表之外的访问成本更低。此外，该 EIP 还引入了访问列表的格式和处理逻辑，这可能会为将来的多个用他用途打下基础。

一句话锐评：新的交易类型有额外的费用，但是新的交易类型内部涵盖了其他需要gas费的操作（列表访问），总体下来可能还便宜了。

**EIP-3198**: BASEFEE 操作码

该提案于 2021 年 1 月 13 日提出，旨在通过引入一个新的 opcode `BASEFEE`（地址为 0x48），允许智能合约访问当前区块的基础费用。这个 opcode 的预计气费为 2，并且不存在已知的向后兼容性问题。`BASEFEE` opcode 的引入有助于智能合约根据基础费用设置奖励、实现气费 futures 等，并且可以提高状态通道、Plasma 和其他基于欺诈证据驱动的解决方案的安全性。

一句话锐评：不好锐评

## 2025.04.04

**EIP-3529**：退款减少

EIP-3529 是一个标准的改进提案，由 Vitalik Buterin 和 Martin Swende 提出，旨在减少对 `SELFDESTRUCT` 和 `SSTORE` 操作的气费退款。该提案在 2021 年 4 月创建，依赖于 EIP-2200、EIP-2929 和 EIP-2930。EIP-3529 的主要目的是减少对 `SELFDESTRUCT` 的退款，并将 `SSTORE` 退款降低到一个较低但仍然有利的水平，以消除当前的 “漏洞” 退款机制。该提案指出，之前的气费退款机制并未达到预期的效果，反而对网络产生了多个不利影响，包括引入 GasToken 的使用和增加区块大小的波动。EIP-3529 通过移除 `SELFDESTRUCT` 的退款，并将 `SSTORE` 的退款降低到一个较低的水平，以解决这些问题。该提案还包括了对退款机制的理由、对向后兼容性的考虑、以及对安全性的考虑。

一句话锐评：主要解决这个退款机制的漏洞

**EIP-3541**：拒绝以 0xEF 字节开始的新的合约代码

合约使用未分配的操作码可能带来安全隐患，因为这些操作码可能会与将来版本中分配的操作码发生冲突。0xEF 是未分配的操作码，而 EIP-3541 建议将其视为无效，以防止未来可能出现的安全问题。虽然目前没有官方的安全漏洞使用 0xEF，但为了避免潜在的语义变化，最好将其视为无效。这个 EIP 也提到了其他类似的操作码，如 0xFD（REVERT）、0xFE（INVALID）和 0xFF（SELFDESTRUCT），它们都是有效的操作码，而 0xEF 并不是一个有效的操作码。

一句话锐评：居然有未分配的操作码。

**EIP-3554**：将难度炸弹延迟至 2021 年 12 月

again

## 2025.04.05

**EIP-3607**：拒绝来自已部署代码发送者的交易

EIP-3607 旨在解决以太坊中可能出现的地址碰撞问题。通过拒绝来自已部署代码的发送者的交易，该提议保护用户免受通过生成地址冲突的方式进行的攻击。由于以太坊地址长度为 160 位，因此理论上可以通过计算来创造地址碰撞，攻击者可能会利用这一点将外部拥有账户（EOA）和合约账户的地址混淆，从而诱导用户误以为账。EIP-3607 建议在区块链的状态转换检查中增加一个额外的规则，即检查发送者的账户是否有部署的代码。如果发送者的账户已经部署了代码，那么相关的交易应该被认为是无效的，并且不应该被网络节点接受或包含在区块中。这个改变可以通过软分叉实施，因为它只是将之前有效的交易定义为无效。

一句话锐评：是哈希碰撞！

## 2025.04.06

**EIP-3651**： Warm COINBASE

EIP-3651：Warm COINBASE 旨在改善以太坊事务处理中的 `COINBASE` 地址状态，使其在事务开始时变为 “热” 状态，这意味着读取这个地址的成本将与实际的消费相符。EIP-3651 的动机在于，随着直接 `COINBASE` 支付的普及，以太坊的访问列表框架下 `COINBASE` 地址初始为 “冷” 状态，这与实际的气费成本不符，可能会鼓励使用除以太坊以外的支付方式。因此，EIP-3651 提出在事务执行开始时初始化 `accessed_addresses` 时包括 `COINBASE` 地址，以反映其在事务执行中的重要性。

一句话锐评：别人都开始绕过你了，想办法让其回归

## 2025.04.08

**EIP-3675**：将共识机制升级为权益证明

EIP-3675 旨在指导以太坊主网从 Proof-of-Work（PoW）共识机制过渡到 Proof-of-Stake（PoS）共识机制，其中包括对新共识机制的规范、客户端配置、PoW 区块处理、区块结构、区块有效性、区块和叔块奖励、分叉选择规则、网络配置等方面的详细说明。该提案由 Mikhail Kalinin、Danny Ryan 和 Vitalik Buterin 于 2021 年 7 月 22 日提出，旨在通过修改区块结构、区块验证性质、分叉选择规则和网络接口来实现共识机制的升级。该提案强调了共识升级的安全性和效率，同时确保了向后兼容性，以最小化对现有应用程序和服务的影响。

一句话锐评：终于来了！

**EIP-3855**：PUSH0 指令

EIP-3855 旨在通过引入一个新的指令`PUSH0`（opcode `0x5f`）来优化智能合约的执行，减少合约部署时的气体消耗。这个新指令将常量值 0 推送到栈上，这在很多情况下是必要的，比如在`CALL`指令中使用零偏移量。该提案的主要动机是减少合约代码大小、减少因改变某些指令价格和行为而产生的风险，以及减少`DUP`指令用于复制零值的需求。分析显示，大约 11.5% 的`PUSH`指令是用来推送值 0 的。此外，如果不使用`PUSH0`指令，合约部署时将会浪费大量气体，因为`PUSH1 00`指令在运行时成本更高。EIP-3855 还强调了新指令的安全性，并明确了它在合约中的应用不会影响 jumpdest 分析。

一句话锐评：优化处理0值时的操作，专门给他一个指令来节省这部分的开支

## 2025.04.09

**EIP-3860**：限制和计量 initcode

EIP-3860 是一个标准跟踪提案，旨在限制 `initcode` 的最大大小为 49152 字节，并为每个 32 字节的 `initcode` chunk（代码块）收取额外的 2 gas。这一提议继承自 EIP-170，目的是为了确保 `initcode` 的长度和复杂性得到适当的计费，防止恶意使用。此外，提案还介绍了相关的规则、背景理由、向后兼容性、测试用例和安全考虑。

一句话锐评：还是在优化gasfee

**EIP-4345**: 难度炸弹延迟到 6月 2022

EIP-4345 通过引入一个虚拟的区块号来实现对难度轰炸的延迟，这个虚拟的区块号在超过 10,700,000 个区块后才开始计算，这样做的目的是为了在 2022 年 6 月至 2022 年 7 月之间减缓区块时间，从而减轻难度轰炸的影响。为Merge腾出空间。

什么时候才会实行呢？

## 2025.04.10

**EIP-4399**：用 PREVRANDAO 替换 DIFFICULTY 操作码。通过替换 DIFFICULTY 操作码的语义，在 EVM 中公开信标链随机数

EIP-4399 提案旨在通过替换 `DIFFICULTY` 操作码的语义，引入 `PREVRANDAO` 操作码，使得以太坊虚拟机（EVM）能够访问信标链随机性。该提案与 EIP-3675（Proof-of-Stake 升级）紧密相关，在 `TRANSITION_BLOCK` 时刻起效。`DIFFICULTY` 操作码在 PoS 升级后不再返回难度值，而是返回信标链随机数（RANDAO）的输出。

一句话锐评：POS的后续操作

## 2025.04.11

**EIP-4788**：EVM 中的信标块根，在 EVM 中公开信标链根

该提案旨在通过将每个信标链区块的哈希树根提交到相应的执行有效负载头中，并将这些根存储在智能合约中，来实现在 EVM 中公开信标链区块根。该规范包括了如何处理区块结构和有效性、为什么不重用 BLOCKHASH、以及为什么使用信标块根而不是状态根等内容。此外，该提供了关于如何部署和处理区块的详细说明。该提案的一个关键观点是，通过这种方式，可以支持各种使用场景，如改善质押池、重新质押构造、智能合约桥、MEV 缓解等的信任假设。

一句话锐评：公开根是为了方便信任

## 2025.04.13

**EIP-4844**：分片 Blob 交易，分片 Blob 交易以简单、向前兼容的方式扩展了以太坊的数据可用性

EIP-4844 提议引入 “Shard Blob Transactions”，旨在通过引入大规模并行处理技术，提高以太坊的数据处理能力，为 rollup 等扩展解决方案提供临时支持，直到完全实施分片技术。

EIP-4844 引入了一种新的交易类型 ——“blob 交易”，这种交易能够包含大量数据，这些数据虽然不能被 EVM 访问，但其承诺可以被访问。该提案继承了 EIP-1559 的燃气管理机制，并引入了一套新的燃气计算方式，专门为 “blob 燃气” 设计。此外，EIP-4844 还引入了新的加密算法和预编译合约，以及相应的共识层和执行层验证逻辑。该提案的主要目标是在完全实施数据分片之前，通过引入分片技术的初步版本，提供临时的扩展解决方案。

**过渡使用的零时方案**

## 2025.04.14

**EIP-4895**：信标链推送提款作为操作，支持从信标链通过新的“系统级”操作类型提取验证者提款到 EVM。

EIP-4895 旨在通过引入系统级别的操作来支持从信标链到 EVM 的验证者提款。这种方法与用户级交易分离，通过在执行有效载荷中引入新的 `withdrawal` 对象来表示提款。这些提款作为一个新的操作类型，独立于常规交易，通过 RLP 列表序列化，并在执行有效载荷头部引入新的 `withdrawals root` 字段来承诺提款列表。这种方法是基于 “推送” 的，而不是 “拉取” 的，即提款必须在执行层中处理，一旦从共识层中出队。EIP-4895 还引入了新的执行有效载荷字段，以及相应的状态转换和安全考虑。

**改为系统级的可以减少交易成本**

## 2025.04.16

**EIP-5133**：推迟难度炸弹至 2022 年 9 月中旬

还在延迟

**EIP-5656**：MCOPY - 内存复制指令，高效的 EVM 指令，用于复制内存区域

IP-5656 旨在通过引入一个新的虚拟机指令 `MCOPY` 来提高内存复制操作的效率。该指令在 `0x5E` 地址上引入，与其他复制指令（如 `CALLDATACOPY` 和 `RETURNDATACOPY`）使用相同的栈输入和输出顺序。`MCOPY` 指令接受三个参数：目标地址 `dst`、源地址 `src` 和复制的长度 `length`。该指令的气体消耗基于 `W_copy` 组的其他指令，具体计算公式为 `g_verylow + Gcopy*ceil(length / 32)`。EIP-5656 提供了测试用例，并通过了完整的测试套件。此外，该提案还讨论了与现有的 `CALL` 指令相关的气体成本，以及 `MCOPY` 指令如何提供对静态分析和优化器的支持。该提案还强调了 `MCOPY` 指令与现有的 `CALL` 指令相比的效率，并考虑到了可能的未来气体成本变化。
<!-- Content_END -->
