---
timezone: UTC+8
---

> 请在上边的 timezone 添加你的当地时区(UTC)，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区


# 你的名字

1. 自我介绍 hi，我是henryleo，生物信息工程师，开放科学/DeSci爱好者，同时也对代币经济学、隐私和区块链在社会治理中的作用很感兴趣。目前专注合成生物学工作。
2. 你认为你会完成本次残酷学习吗？ 我想我可以！
3. 你的联系方式 https://github.com/henrycyberbio/

## Notes

<!-- Content_START -->

### 2025.03.10

#### 用户转账ETH的燃料费
燃料费=基础费用+优先费，这个费用不能低于燃料限额，燃料限额和基础费用由以太坊决定，优先费是给验证者的小费，由用户决定。这意味着用户只需要考虑优先费即可。
##### 第一种方式：完全手动设定

例如，Gas限额=21000Gwei，基础费用为100Gwei，优先费为10Gwei，则用户实际需要支付的费用为：
$$
Gas=GasLimit*(Base+Priority)=21000*(100+10)Gwei=2310000Gwei=0.00231ETH
$$
##### 第二种方式：设定最高收费
maxFeePerGas 最高收费

当用户设定的最高收费大于基础费用与优先费之和，则会退回多余部分：
$$
repay=maxFeePerGas-(BaseFee+Priority)
$$
当最高收费小于基础费用与优先费之和，则需要排队

##### 第三种方式：设定最高优先费
maxPriorityFeePerGas 最高优先费

当使用这种设置时，假设不需要排队，则收费肯定大于需要的费用：
$$maxFeePerGas>(BaseFee+Priority)$$
移项，即，当优先费小于最大费用与基础费用之差时，必然上链：
$$Priority<maxFeePerGas-BaseFee$$
那么为了节约Gas费或避免巨额Gas费的情况，可以设定最高优先费 maxPriorityFeePerGas：
$$Priority=min(maxPriorityFeePerGas, (maxFeePerGas-BaseFee))$$
这个公式意味着当网络不繁忙时（`maxFeePerGas-BaseFee`较小），选择立即成交的优先费用；当网络繁忙时，可以选择预期的最高优先费，开始排队。


### 2025.03.11
上文提及基础费用是以太坊网络决定的，实际上有一个简单的公式，一个区块当前的基础费用是**由上一个区块是否超出了网络最大设定的最大燃料费的一半**来决定，即：
$$
BaseFee\equiv
\left \{
\begin{array}{l}
10^{9}, if\space伦敦升级之前 \\
Gas_{PrevBlock}, if\space Gas_{PrevBlock}=\frac{GasLimit}{2} \\
Gas_{PrevBlock}*(1+A), if \space Gas_{PrevBlock}>\frac{GasLimit}{2} \\
Gas_{PrevBlock}*(1-B), if \space Gas_{PrevBlock}<\frac{GasLimit}{2} \\
\end{array}
\right.
$$
这个方案的动态在于A是可变的，A的范围是`0 ~ 12.5%`、B是`-10% ~ 0`

**已勘误至2025.03.14笔记**


### 2025.03.12

今天主要分析了联盟链和以太坊共识机制的区别，联盟链在实际应用中做出了一种权衡：牺牲部分完全去中心化的特性，换来了更高的效率、合规性和业务适用性。在这种场景下，外部机制确保的信任实际上与区块链的技术特性相辅相成，共同实现了一个高效、可信和多方协同的数据网络。

### 2025.03.13

**燃料费** 是以太坊执行层根据网络需求设定的计算成本单位，而 **Gwei** 是以太币（ETH）的最小单位之一（$1 Gwei = 10^{−9}\space ETH$）。

当用户在以太坊上执行交易或智能合约时，所需的 **Gas 量** 取决于操作的计算复杂度和存储占用。这部分 Gas 需求是 **固定的**，但 **每单位 Gas 的价格（Gas Price）** 以 Gwei 计价，并会随网络的繁忙程度波动。

最终的 **燃料费（交易费用）** 计算方式如下：

$$交易费用=Gas 消耗量×Gas Price (Gwei)$$

因此，在网络拥堵时，Gas Price 上升，交易费用变高；而在网络空闲时，Gas Price 下降，交易费用变低。在理解这两个概念时要万分注意。

### 2025.03.14
在学习了Gas和Gwei的区别后对上述笔记进行修改：

基础费用的单位是Gwei，因此基础费用的变化影响的是燃料费和ETH的“汇率”，而并不影响交互本身需要多少燃料完成。

上文提及基础费用是以太坊网络决定的，实际上有一个简单的公式，一个区块当前的基础费用是**由上一个区块是否超出目标燃料费**来决定，目标燃料费在EIP1559设定为燃料限额的一半，即：
$$
BaseFeePerGas\equiv
\left \{
\begin{array}{l}
10^{9}, if\space伦敦升级之前 \\
BaseFeePerGas_{PrevBlock}, if\space BaseFeePerGas_{PrevBlock}=\frac{GasLimit}{2} \\
BaseFeePerGas_{PrevBlock}*(1+A), if \space BaseFeePerGas_{PrevBlock}>\frac{GasLimit}{2} \\
BaseFeePerGas_{PrevBlock}*(1-A), if \space BaseFeePerGas_{PrevBlock}<\frac{GasLimit}{2} \\
\end{array}
\right.
$$
这个方案的动态在于A是可变的，A的范围是`-12.5 ~ 12.5%``

而A的算法是：
$$
A = \frac{GasUse_{PrevBlock}-Gas_{target}}{Gas_{target}}*12.5\%
$$
A也叫做基础费用的变化幅度。

这个里面有许多可以用于调整以太坊经济模型的参数，如：
- 燃料费限额
- 燃料费目标或弹性系数（$\frac{GasLimit}{2}$，分母也叫弹性系数 Elasticity multiplier，现在是2）
- 基本费用最大分母（$\frac{1}{8}=12.5\%$，这是最极端的情况下，当前区块燃料费为零，那么分子为（燃料费限额-0）/燃料费限额=1。这个分母也可以调整）

#### refs:
- [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)
- [以太坊Gas费(Ethereum Gas Fees)详细介绍：gas费计算、gas费实时查询、gas 费预测、ethereum gas tracker、ethereum gas charts | 币圈小林子](https://www.youtube.com/watch?v=eMX85xai2-U)
- [燃料和费用|EF](https://ethereum.org/zh/developers/docs/gas/#base-fee)



### 2025.03.16
#### 基本交易成本

常见的基本交易燃料 Intrinsic Gas 分两类：
- **普通转账（ETH 发送）**：21,000 Gas，用于交易验证和签名验证
- **合约调用**：21,000 Gas + 额外计算消耗
- **合约创建**：21,000 Gas + 32000 Gas，用于存储合约代码和初始化状态

其中，转账基础费用记为 $G_{transaction}​=21000Gas$ ，合约创建费用记为 $G_{txCreate}=32000Gas$ 


### 2025.03.17
#### 合约数据的燃料成本
Calldata 是指随交易发送到智能合约的输入数据，Calldata需要占用链上的储存和运输，其每个字节都要消耗燃料。根据其字节的类型消耗量不同：
- 零字节（0x00）：4 Gas
- 非零字节：16 Gas


### 2025.03.18
#### 计算合约执行成本

智能合约的底层操作是通过EVM 操作码执行，每个操作码代表一种特定的操作，各操作码所需燃料费请见：[EVM操作码|EF](https://ethereum.org/zh/developers/docs/evm/opcodes/)

在以太坊中，有两类操作：**计算（Computation）** 和 **存储变更（Storage Modification）** 但它们的 Gas 成本计算方式和对网络的影响大不相同。
##### 计算 Computation
计算指的是 EVM 运行智能合约时执行的算术、逻辑、数据操作等。
- 主要包括：`ADD`、`MUL`、`DIV`、`LT`、`EQ`、`SHA3`、`CALL`、`RETURN` 等指令。
- 这些指令的 Gas 成本通常是 **固定的** 或 **动态计算的（如 EXP）**，但不会对区块链的长期状态产生影响。

##### 存储变更 Storage Modification
主要涉及对合约 storage 存储 变量的读写，即 `SLOAD`读取存储槽 和 `SSTORE`写入存储槽

**存储比计算昂贵得多**，因为存储变更会永久写入以太坊的状态数据库，消耗较多的磁盘 I/O 和同步成本

###### SLOAD
根据EIP-2929，`SLOAD`操作的燃料消耗分为两种：
- Cold Storage Slot 冷储存槽：如果这是本次交易中首次访问的存储槽，SLOAD 操作会消耗 2100 Gas
- Warm Storage Slot 温储存槽：如果该存储槽在本次交易中已被访问过，SLOAD 操作仅消耗 100 Gas

[SLOAD | EVM操作码 | Github](https://github.com/wolflo/evm-opcodes/blob/main/gas.md#a6-sload)
###### SSTORE
同样的，`SSTORE`也会根据冷、温储存槽增减燃料费，如果是冷储存槽则增加2100Gas。[SSTORE | EVM操作码 | Github](https://github.com/wolflo/evm-opcodes/blob/main/gas.md#a7-sstore)

根据储存值，燃料费有以下机制：
- 从 0 改为 非 0：
    - 消耗 20,000 Gas：将存储槽从零值修改为非零值时，需要消耗 20,000 Gas。
- 从 非 0 改为 0：
    - 消耗 5,000 Gas，且在交易执行成功后可退款 15,000 Gas：将存储槽从非零值修改为零值时，初始消耗 5,000 Gas，但由于释放了存储空间，协议设计允许在交易成功执行后返还 15,000 Gas。
- 从 非 0 改为 另一个 非 0：
    - 消耗 5,000 Gas：将存储槽从一个非零值修改为另一个非零值时，消耗 5,000 Gas。


### 2025.03.19

#### 合约数据和操作码中的数据的异同

Calldata比储存变更的操作码燃料费便宜很多（4 Gas vs 2100 Gas），这是为什么呢？

以`SLOAD`为例，对比：

| **对比项**          | **Calldata**      | **SLOAD（存储读取）**  |
| ---------------- | ----------------- | ---------------- |
| **数据位置**         | 交易调用时附带的临时数据      | 以太坊合约存储（storage） |
| **可变性**          | 只读，不能修改           | 可读可写，修改成本高       |
| **存储持久性**        | 仅在交易执行时可用         | 持久存储在区块链上        |
| **访问成本（Gas 费用）** | 低（4 Gas / 16 Gas） | 高（2100 Gas 及以上）  |
| **数据生命周期**       | 交易结束后丢弃           | 永久存储在区块链上        |
| **适用场景**         | 传递外部输入数据          | 读取合约的长期状态数据      |

原因：
- Calldata 存储在 EVM 的调用数据区（Call Data Area），**不会永久存储**。它只在交易执行期间存在，并且不会影响以太坊的全局状态，所以读取的成本很低。`SLOAD`读取的是智能合约的 Storage（存储区），这是以太坊的永久存储。**存储在 Storage 里的数据会随着区块链的增长而永久保留，每次读取都涉及状态数据库访问**，因此成本更高。
- 以太坊存储是 Merkle Patricia Trie，读取慢，Calldata不需要这些。
- Calldata 只读，不需要考虑状态变更。`SLOAD` 读取的数据可能会被 `SSTORE` 修改，EVM 需要进行额外的存储保护机制，以防止篡改数据，因此消耗更多 Gas

### 2025.03.20

Data Availability Sampling DAS 数据可用性采样 是以太坊路线图The Surge的重要子项，是为了使得轻量级客户端可以通过随机抽样方式检查数据是否可用，而不必下载整个区块。  这将进一步提高数据可用性的效率，同时降低网络带宽需求。

数据可用性采样的技术基础是Polynomial Commitment Scheme PCS 多项式承诺方案，它是一个广泛的概念，指的是允许一方（Prover）对一个多项式进行承诺，并在之后向另一方（Verifier）证明该多项式在特定点的值的密码学方案。而Kate-Zaverucha-Mallina Commitment Scheme KZG多项式承诺是PCG的一种非常流行和高效的特定实现。

#### 多项式承诺方案的重要概念

- **Commitment 承诺**：Prover 计算并发送一个对多项式的简洁承诺给 Verifier。这个承诺应该具有约束性，即 Prover 无法在之后改变其承诺的多项式。
- **Proof 证明**： 当 Prover 想要证明其承诺的多项式 `P(x)` 在某个特定点 `z` 的值为 `y` 时，Prover 需要生成一个证明。
- **Verification 验证**： Verifier 接收到承诺、点 `z`、值 `y` 和证明后，能够验证该证明的有效性，从而确认 `P(z)` 是否确实等于 `y`。
- **Succinctness 简洁性**： 承诺和证明的大小通常远小于多项式本身的规模。

#### KZG在数据可用性采样的应用举例

在一个区块链系统中，区块提议者 需要发布一个包含交易的数据块。为了让整个网络信任这个区块的有效性，需要确保所有的数据都是可用的，即使区块提议者可能试图隐藏部分数据。数据可用性采样就是一种让轻客户端（只下载少量数据的节点）能够以高概率验证整个数据块是否已被公开的技术。

KZG 多项式承诺非常适合 DAS：
- **简洁的承诺：** 可以为一个很大的数据块生成一个非常小的承诺。
- **简洁的证明：** 可以为数据块中的任何特定位置生成一个非常小的证明，证明该位置的数据与承诺一致。
- **高效的验证：** 轻客户端可以使用承诺和证明快速验证特定位置的数据是否正确。

假设一个区块的数据被分成了 4 个数据块：$D_0$，$D_1$，$D_2$，$D_3$。
1. 数据编码为多项式：区块提议者将这 4 个数据块视为一个 3 次多项式 P(x) 的系数。我们可以将数据块映射为多项式在特定点的求值，或者直接作为系数。为了简化，我们假设数据块是多项式的系数： $P(x) = D_0 + D_1 * x + D_2 * x^2 + D_3 * x^3$
2. KZG 承诺：区块提议者使用 KZG 承诺方案，对多项式 P(x) 生成一个承诺，是一个固定大小的值（在实际中是椭圆曲线上的一个点）。
3. 数据可用性采样：轻客户端收到$D_1$ 和 Proof 1 后，使用之前收到的承诺，以及索引 1，来验证 Proof 1 是否有效。这个验证过程会确认 $D_1$ 的确是与承诺的 P(x) 在 x = 1 处的值一致。同样地，轻客户端收到 $D_3$ 和 Proof 3 后，使用承诺 和索引 3 来验证 Proof 3 是否有效，确认 $D_3$ 与 P(x) 在 x = 3 处的值一致。
4. 增加置信度：轻客户端会进行多次独立的随机采样。每次成功验证一个数据块，轻客户端就对整个数据块的可用性增加一些信任。如果经过足够多次的采样，并且所有的验证都成功通过，那么轻客户端就可以以非常高的概率确信区块提议者已经公开了所有的数据块。即使提议者只公开了部分数据，随机采样也很可能命中那些未公开的部分，导致验证失败。

#### KZG在数据可用性采样的重要结论

> 有50%的数据就可以恢复全部数据

在数据可用性采样的场景下，之所以会有“假设有 50% 的数据就可以恢复全部数据”的说法，主要是因为 **通常会结合使用Erasure Coding 擦除编码 **，例如 **Reed-Solomon 码**。

- 在 DAS 中，为了提高数据的容错性和可用性，原始的数据在发布之前通常会经过擦除编码。
- 擦除编码的原理是将原始的 `k` 个数据块扩展到 `n` 个编码后的数据块，其中 `n > k`。这额外的 `n-k` 个数据块包含了冗余信息。
- **关键特性：** 只要拥有任意 `k` 个（或更多）的编码后的数据块，就可以通过特定的解码算法恢复出全部原始的 `k` 个数据块。

50% 的恢复能力实际上是一种常见的配置导致的，在许多实际的 DAS 设计中，会选择一种配置，使得编码后的数据量是原始数据的两倍。也就是说，如果原始数据被分成 `k` 个块，那么经过擦除编码后会得到 `2k` 个块。

回到上述的例子，假设区块提议者是恶意的，那么它至少要使得50%的数据可用，且当验证者随机要一个数时恰好那个数在这50%中（不在就穿帮了）。那么根据联合概率，$\frac{1}{0.5^{30}}>1,000,000,000$  ，即只要抽30个数，那么造假成功的概率低于十亿分之一。

### 2025.03.22

在 EIP-4844 之前，交易的所有数据（包括 Layer-2 提交的大量交易数据）都直接包含在以太坊交易的 `calldata` 字段中。这些数据不仅需要在共识层可用，也需要在执行层被处理和存储，这导致了较高的 Gas 成本。

EIP-4844 引入了新的 "data blobs" 来降低 Layer-2 扩容方案的成本。这些 blobs 是与交易分开存储的大块数据，它们在共识层是可用的，但在执行层不可直接访问。

这类交易包含：
- 普通交易字段（nonce、gas limit、to、value 等）
- Blob 数据（L2 交易的批量数据）
- Blob KZG 承诺（KZG Commitment），用于保证 Blob 数据的完整性

Blob 数据本身 **不会存入执行层**，而是由共识层存储并保证可用性。


### 2025.03.24

#### 卷叠中的燃料费计算
此处专指EIP-4844后的燃料费计算，此次升级新增了Blob数据结构，这种结构大大节省了L2的燃料费。这些 blobs 是与交易分开存储的大块数据，它们在共识层是可用的，但在执行层不可直接访问.虽然数据 blob 本身存储在共识层，但**触发**和**引用**这些 blob 的操作发生在执行层上的交易中。因此，燃料费的支付仍然通过执行层上的交易来完成。

$$Blob Gas Fee = Blob Base Fee * blobGasUsed$$
- `BlobBaseFee` 是当前区块的 blob 基础费用。
- `blobGasUsed` 是与该交易关联的所有 blob 的总 Gas 消耗。每个 blob 都有一个固定的 Gas 成本（例如，每个 blob 131072 字节，对应 1 个 blob gas 单位）。

##### 汇率控制
 `BlobBaseFee`和EIP-1559中的基础费用不共享一个汇率，以 `wei/blobGasUnit` 为单位。一个`blobGasUnit`对应一个完整的数据 blob (目前大小约为 128 KB)，一个Blob被定义为消耗$2^{17} = 131072$个`BlobGas`单位
 
根据目标 Blob Gas 使用量和最大 Blob Gas 使用量进行调整。如果实际使用的 blob gas 超过目标，blob 基础费用会增加；如果低于目标，blob 基础费用会减少。具体：
- 目标 Blob 数 (Target Blobs Per Block): 3 个
- 最大 Blob 数 (Max Blobs Per Block): 6 个
- 调整公式 (近似描述): Blob 基础费用的调整基于一个指数函数，更具体地说是根据一个与“超出目标 Blob 数量”相关的因子进行调整。
- 更精确的公式涉及一个累积的超出量 (excess blob gas) 和一个预设的常数。大致来说，当每个区块使用的 Blob 数量超过 3 个时，**Blob 基础费用会指数级增长。当使用量低于 3 个时，Blob 基础费用会线性下降**。
##### 实例
假设目前的汇率是`1 weiPerBlobGas`，那么每个Blob的费用只有0.000131Gwei：
 $$1 \space weiPerBlobGas * 2^{17}BlobGas = 0.000131\space Gwei \space PerBlob$$
一个Blob可以承担128KB，一笔ETH交易大约是200~300字节，那么：
$$131072 字节 \div 200 字节 = 655.36(笔)$$

同样一笔交易，在主链上需要大约需要：
$$Gas=GasLimit*(Base+Priority)=21000*(100+10)Gwei=2310000Gwei=0.00231ETH$$
而在二层链只需要：
$$Gas=0.000131\space Gwei \div 655.36=0.0000002\space Gwei=2^{-16}\space ETH$$
虽然在二层链可能有优先费等其他费用最终不会这么低，但也是一个十分惊人的差距

### 2025.03.25
The Scourge是关于MEV和质押代币经济学的开发和研究方向

Maximal Extractable Value MEV 最大可提取价值，曾经也被称为Miner Extractable Value 矿工可提取价值

MEV是指区块生产者（以前是矿工，现在是验证者）可以通过在他们提议的区块中**重新排序、插入或审查**交易来提取的额外利润，这超出了正常的区块奖励和交易费用。

MEV 的产生源于以下几个关键因素：

- Mempool 公开的交易池
- 区块生产者的排序权
- 市场机会和信息不对称

MEV 的运作通常涉及以下几种策略：

- Arbitrage 套利： 在不同的去中心化交易所（DEX）之间，同一资产的价格可能存在微小的差异。MEV 搜索者可以发现这些差异，并在一个交易所买入，同时在另一个交易所卖出，从而获利。他们会通过调整交易顺序，确保自己的交易在价格有利的时刻被执行。
- Front-running 抢跑交易：当一个大型的、公开可见的交易（例如在 DEX 上购买大量代币）即将被执行时，MEV 搜索者可以提交一个自己的交易，使其在目标交易之前被执行。这通常会导致目标交易的价格上涨，从而使抢跑者获利。
- Sandwich Attack 三明治攻击：攻击者会提交两个交易，一个在目标交易之前，另一个在目标交易之后。前一个交易会推高目标交易的价格，而目标交易执行后，后一个交易会以更高的价格卖出，从而获利。
- Liquidation 清算：在一些去中心化借贷协议中，当借款人的抵押品价值低于一定阈值时，任何人都可以发起清算。MEV 搜索者会监控这些机会，并优先执行清算交易以获取奖励。
- Censorship 审查：在某些情况下，区块生产者可能会选择不包含某些特定的交易到区块中。这可能出于各种原因，例如合规性要求或避免某些类型的交易。

### 2025.03.26
#### 为什么要控制MEV市场？

狂野的MEV市场并不好，能够高效提取 MEV 的实体（例如，拥有先进算
法和基础设施的矿工或验证者）可能会获得不成比例的收益。这对独立验证者极不公平，这样会有越来越多验证者选择去矿池质押而不是独立，导致网络的中心化，这些实体更有能力积累更多的资源（例如，更多的 ETH 来进行质押），从而进一步巩固其权力。

#### 既然MEV市场有害为什么不消除它呢?

MEV 本质上是由于区块链交易的排序和包含所产生的价值。只要存在交易费用、去中心化交易所（DEX）之间的价格差异、清算机会等，就存在提取 MEV 的可能性。完全阻止这些机会可能需要对区块链的基础架构进行根本性的改变，这可能会带来新的问题。在某些情况下，MEV 可以作为网络参与者（如矿工或验证者）的一种额外的经济激励，以确保网络的正常运行和安全性。例如，清算机器人通过执行清算操作来维持借贷协议的健康，并因此获得 MEV 作为奖励。


### 2025.03.27

PBS Proposal Builder Separation 提案者-构建者分离

在以太坊 The Merge 之后以太坊的共识机制转为PoS，Proposer 提案者是**在共识层负责提议新的区块的验证者**，他们既是区块的提议者也是区块的构建者。

PBS旨在将区块内的执行负载的构建外包给第三方——Builder 构建者负责构建区块的实际内容的实体，即**在执行层执行有效负载**

PBS旨在通过分离提案者和构建者的角色，实现
- **增强去中心化:** 减少提案者在 MEV 提取方面的权力，降低中心化风险。
- **提高安全性:** 通过更清晰的角色分离，降低潜在的攻击风险。
- **提升效率:** 通过协议级别的集成，简化提案者和构建者之间的交互。
- **解决中继节点依赖问题:** 消除当前 PBS 实现中对中继的依赖，提高系统的鲁棒性。

### 2025.03.28

#### MEV-Boost 
MEV-Boost (Maximum Extractable Value-Boost) 旨在在不修改以太坊底层协议的情况下，尽可能实现PBS。MEV-Boost 充当中间件，本质上通过中继节点实现区块构建者和验证者之间的通信。

**工作流程总结:**
1. **构建:** 区块构建者构建包含 MEV 交易的区块
2. **提交:** 区块构建者将构建好的区块（以及出价）提交给一个或多个中继器
3. **验证:** 中继器验证区块的有效性
4. **广播:** 中继器将通过验证的区块和出价广播给验证者
5. **竞标:** 验证者的 MEV-Boost 客户端从多个中继器接收区块和出价
6. **选择:** 验证者选择出价最高的区块
7. **提议:** 验证者签署并提议选定的区块到以太坊网络
8. **奖励:** 提议者（验证者）会收到区块构建者支付的出价作为奖励

**验证者明明可以又做构建者又作提案者，从而避免竞标，为什么验证者愿意去用它呢？**

- 专业化和效率提升：在EVM写到，可提取的价值类型很多，每个赛道要求都很高，又因为提案者是随机选定的，对于独立验证者而言，直接选择专业构建者的区块可以获得更高的EVM。
- 市场竞争和效率：多个区块构建者为了赢得验证者的区块空间，会相互竞争，提供更高的出价。

**缺点：**

- 信任中继节点： 验证者需要信任他们连接的中继器，因为中继器在选择和广播区块方面扮演着关键角色。
- 中心化风险：虽然理论上可以有多个中继器，但实际中可能存在少数几个占主导地位的中继器，这可能带来一定的中心化风险。
- 审查风险：中继器和构建者可能会受到审查压力，从而影响区块的包含。

### 2025.03.29

Enshrined PBS 嵌入式PBS，它允许共识提议者选择构建者。EIP-7732 的主要目标是解决当前系统中存在的“强制信任参与者”的问题，具体来说是指 MEV-Boost 中的中继 。目前，验证者通常依赖 MEV-Boost 等第三方服务来最大化其收益，这引入了信任假设 。

EIP-7732 通过将提议者-构建者分离直接纳入协议本身来解决这个问题，将区块创建过程划分为两个不同的角色：共识提案者和执行提议者（构建者）。**区块构建者**则负责将所选交易组织成优化的区块格式，专注于效率和速度，他们创建执行区块 。EIP-7732 引入了一个正式的**提案者-构建者接口**，确保提案者可以信任构建者正确构建区块，而无需直接参与交易选择过程。这降低了提案者对构建者诚信的依赖 。

### 2025.03.31

一种数据结构，和Merkle tree一样提供一种高效且安全的方式来验证大量数据的完整性，与Merkle Tree相比，Verkle Tree的证明大小很小，不需要完整的数据即可证明其完整性，这对于以太坊轻节点来说很有吸引力。

Verkle Tree是一种使用Vector Commitments 向量承诺 的数据结构，可以通过路径证明交易，例如基于Polynomial Commitments 多项式承诺，在数据可用性采样中提过，只需要**帐本中的几个点**即可完成证明。

#### Merkle vs Verkle

以下是一个有16个交易记录的简单账本，假设要证明 $TX_7$，分别使用两者数据类型
![2025033101](https://www.researchgate.net/profile/Subhash-Suri/publication/220978848/figure/fig2/AS:667707695439877@1536205328505/The-basic-tree-topology-on-16-leaves_W640.jpg)

首先是Merkle，树的高度为 $log_2(16) = 4$ ，需要以下节点的哈希值：
- $TX_8$；由于已经有了$TX_7$的记录和$TX_8$的哈希值，组合为$TX_{7-8}$
- $TX_{5-6}$；与$TX_{7-8}$组合为$TX_{1-4}$
- $TX_{1-4}$；与$TX_{5-6}$组合为$TX_{1-8}$
- $TX_{9-16}$，与$TX_{1-8}$组合为根节点$TX_{1-16}$
除此之外，还需要$TX_{1-16}$与我们计算得到的根节点相互对比以证明其一致。可以发现，证明大小=树的高度，当交易记录增加到1024条的时候，则需要$Log_2(2^{10})=10$ 条哈希，即空间复杂度为：
$$Log_2(n)$$

其次是Verkle，首先要确定确定 根节点到$TX_7$​ 的路径：
- $TX_{1-16}$：要到达$TX_7$ ，需要向$TX_{1-8}$移动，`0`，零代表左子树，一代表右子树
- $TX_{1-8}$：向$TX_{5-8}$移动，`0->1`
- $TX_{5-8}$：向$TX_{7-8}$移动，`0->1->1`
- $TX_{7-8}$：向$TX_{7}$移动，`0->1->1->0`
即编码为`[0,1,1,0]`，下一步构造证明：
- 根承诺
- Path 路径：`[0,1,1,0]`
- Sibling Commitments 兄弟承诺：
    - 选了$TX_{1-8}$，所以要$TX_{9-16}$的承诺
    - $TX_{5-8}$，需要$TX_{1-4}$的承诺
    - $TX_{7-8}$，需要$TX_{5-6}$的承诺
    - $TX_{7}$，需要$TX_{8}$的承诺
- 叶子节点值

乍看之下和Merkle没有区别，都需要兄弟节点的信息，但其实性质不同！对于Verkle需要的是承诺而不像Merkle一样需要兄弟节点的哈希值，完全可以通过多项式魔法获得一组值（兄弟节点的哈希）的承诺，此时算法复杂度是**常数级别**的。很有趣，具体如何运算待补。

### 2025.04.01

#### The Purge
这个部分主要是做所谓清理，让协议变得更清晰、更简单
- EIP-4444 节点不需要保存超过一年的记录
- State Expiry 状态过期
- RLP to SSZ 交易编码清理

#### The Splurge
杂项
- EOF EVM Object Format 以太坊虚拟机对象格式
- Endgame EIP1559
    - AMM 自动做市商化 监控Gas用量而不是仅仅考虑上一个区块的用量，并提高审查的成本
    - 多维的EIP-1559 对以太坊资源的多维定价方式，例如Blob 定价方式与EIP-1559不同
    - EIP-4396 时间纳入基本费用的考量 假设验证者错过了一个时隙，下一个区块会填充更多交易，网络会以为需求激增，但这是不对的，这是供应短缺造成的
- Account Abstraction 账户抽象 特别对于EOA来说很麻烦
- Deep cryptography 高级密码学技术
    - 全同态加密
    - One-Shot Signatures 单次签名 签名后销毁签名本身
- 完全加密的mempools
- VDF（可验证延迟函数）
- ...

### 2025.04.02
接下来将花一点的时间研究ZK-STARKs。[参考](https://vitalik.eth.limo/general/2021/01/26/snarks.html)

### 2025.04.03
一种非对称密码学，由Ron Rivest、Adi Shamir 和 Leonard Adleman首次发表，故称RSA。

RSA的加密方法：随机选择两个素数，相乘获得一个最大数$Max$；再分别选择两个大于$0$且小于$Max$的数字作为公钥和私钥，分别记为$Pub$和$Priv$。
- 加密一个数：将其乘以自身$Pub$次，确保在达到最大值时 **Wrap around 回绕**
- 解密一个数，将其乘以自身$Priv$次，然后返回原始数字

其中，$Max$、$Pub$和加密后的信息是公开的

私钥生成—— Extended Euclidean algorithm 扩展欧几里得算法
$$Max = p * q$$
计算欧拉函数：
$$φ(Max) = (p - 1)(q - 1)$$
选择一个公钥，使其$1 < Pub < φ(Max) 并且 $Pub$ 和 $φ(Max)$ 互质（即它们的最大公约数为 1）。

计算一个私钥，使其满足：
$$ (Priv * Pub)\space mod \space φ(Max) = 1$$

**举例**
给定素数 13 和 7，它们的乘积给出的$Max$是 91。假设公钥是数字 5。然后利用我们知道 7 和 13 是 91 的因数这一事实，并应用扩展欧几里得算法，得到私钥是数字 29。

由此定义了一个RSA加密系统（$Max: 91, Pub: 5, Priv: 29$），取一个数字并将其乘以自身 5 次以对其进行加密，然后取该数字并将其乘以自身 29 次即可得到原始数字。

![RSAFig1|625](https://cf-assets.www.cloudflare.com/zkvhlag99gkb/5xUJlv5Lvw5dMwlAwpXcTM/b0bc17dc2998bc90c212c2ab7df8661f/image05.png)

假设要加密单词“CLOUD”，根据UTF-8编码，该单词被编码为`67、76、79、85、68`

以第一个字母 L (67) 为例，先乘以自身5次，若大于91则回绕：
 - $67*67=4489=30$，为什么会等于30，这是因为4489大于最大值91，所以需要除以91取余，$4489=91*49+30$
 - $30×67 = 2010 = 8$
 - $8×67 = 536 = 81$
 - $81×67 = 5427 = 58$
重复五个字母后得`58, 20, 53, 50, 87`

解密该消息，将它们乘以自身29次：
- 58×58 = 3364 = 88
 - 88×58 = 5104 = 8
 - ...
 - 9×58 = 522 = 67
 
第一位竟然神奇的恢复了！

**缺陷**
RSA的破解实际上是在做因式分解。同上例系统，我们已知被加密的L为`59`、最大数91以及公钥为5，本质上要去找一个私钥，还原L

即要找一个数$Priv$，满足：
$$(Priv * Pub)\space mod \space φ(Max) = 1 = (Priv*5)\space mod \space φ(91)$$
即找到$φ(91)$即可破解私钥，那么已知：
$$φ(91) = (p - 1)(q - 1)$$
只需要穷举一个素数对，使得：
$$q*p=91$$
“因式分解”通常特指将一个合数分解成它的质因数的乘积。了解这一点之后，目前有一些方案计算因式分解比较高效，而且当$Max$越大效率越高，甚至高于加密时乘以大数的难度！这意味着本来我们期待用更大的素数对相乘以获得更好的安全效果这实际上在RSA中不可行。

**Refs**
- [椭圆曲线密码学入门 | Nick Sullivan](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)


### 2025.04.04
路径：要了解ZK-STARKs，ECC是基础，要了解ECC先了解RSA。

今天抽半个小时研究ECC，没有很看懂！下次继续努力~


<!-- Content_END -->
