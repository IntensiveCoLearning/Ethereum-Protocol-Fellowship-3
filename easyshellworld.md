---
timezone: UTC+8
---

> 请在上边的 timezone 添加你的当地时区(UTC)，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区


# None

1. 自我介绍: 
无名的人阿！

>我是这路上 没名字的人
我没有新闻 没有人评论
要拼尽所有 换得普通的剧本
曲折辗转 不过谋生
我是离开 小镇上的人
是哭笑着 吃过饭的人
是赶路的人 是养家的人
是城市背景的 无声
我不过 想亲手触摸
弯过腰的每一刻
留下的 湿透的脚印 是不是值得
这哽咽 若你也相同
就是同路的朋友

2. 你认为你会完成本次残酷学习吗？ 
坚持一下呗！  

3. 你的联系方式:
 

## Notes

<!-- Content_START -->

### 2025.03.10
#### 重走学习路
* 主要针对：`https://epf.wiki/#/eps/week1`第一周内容进行学习
* **回顾uinx** UNIX 是一种**多用户**、**多任务**、**文件系统**、**模块化**、**权限管理**的操作系统。
  * 从而衍生出来设计理念：
   > “小而精”（Do One Thing and Do It Well）：每个程序应该只做一件事，并且做到极致。
   “一切皆文件”（Everything is a File）：设备、进程、网络等都用文件表示，统一操作方式。
   “管道”机制（Pipes & Filters）：将多个小程序组合，利用 |（管道）连接，使数据流动，提高灵活性。
   模块化设计：程序可以像乐高积木一样组合使用，而不是一个庞大复杂的单体程序。
* **非对称加密** 使用一对密钥：公钥用于加密，私钥用于解密，解决了对称加密中密钥分发的难题，允许安全的通信和身份验证。此外，非对称加密支持数字签名功能，发送者使用私钥签名，接收者使用公钥验证签名的真实性和完整性。其他功能与应用包括：密钥交换，例如ElGamal加密算法用于安全地交换对称加密所需的密钥；基于身份的加密，通过将用户的身份信息直接用作公钥，简化密钥管理过程，如组合公钥（CPK）是一种基于标识的非对称公钥管理体制，能够通过微小的生成矩阵产生近乎无限的密钥，解决密钥管理中的规模化难题；椭圆曲线密码学（ECC），利用椭圆曲线数学结构，提供与传统加密算法相同的安全性，但使用更短的密钥长度，提高了效率，广泛应用于资源受限的环境，如移动设备和智能卡；最优非对称加密填充（OAEP），是一种与RSA加密一起使用的填充方案，通过添加随机性元素和防止部分解密，增强了加密的安全性。
* **黄白书** 以太坊是一个去中心化的平台，旨在支持智能合约和去中心化应用（dApps）的开发和运行。其核心架构包括以下关键组件：
    * **框架结构：**
        * **账户：** 以太坊支持两种类型的账户：外部拥有账户（EOA）和合约账户。EOA由私钥控制，主要用于用户发起交易；合约账户由智能合约代码控制，能够在接收到交易时执行特定代码。
        * **交易：** 交易是从一个账户到另一个账户的信息传递，可能包含数据和价值转移。交易可以触发智能合约的执行，导致状态的改变。
        * **区块链：** 以太坊的区块链由一系列区块组成，每个区块包含多个交易。区块按时间顺序链接，形成一个不可变的记录。
    * **状态机：** 以太坊的状态机定义了系统的状态及其变化规则。系统状态由所有账户的状态组成，包括账户余额、存储数据等。每笔交易都会引起状态转换，新的状态取决于当前状态和交易的具体内容。
    * **执行层：** 执行层负责处理交易和执行智能合约。以太坊虚拟机（EVM）是执行层的核心组件，能够解释和运行智能合约的字节码。EVM提供了一个沙盒环境，确保合约代码的执行不影响主机系统的安全性。
    * **共识层：** 共识层确保网络中所有节点对区块链的状态达成一致。以太坊最初采用工作量证明（PoW）共识机制，要求矿工解决复杂的数学问题以验证交易和生成新区块。然而，随着以太坊2.0的推进，网络正逐步转向权益证明（PoS）机制，通过质押以太币来参与共识过程，提高网络的可扩展性和能源效率。


### 2025.03.11
#### 2th
* **路线图**
  ![](https://pbs.twimg.com/media/GCntEVFWwAAoWeI?format=jpg&name=large)
    * 这个路线图展示了 **以太坊（Ethereum）** 的未来发展计划，包括多个主要阶段和改进方向。它分为 **五大部分**，分别代表以太坊的关键技术升级：
      1. **The Merge（合并）**  
            - **已完成（2022 年 9 月）**  
            - 以太坊从 **工作量证明（PoW）** 过渡到 **权益证明（PoS）**，减少能源消耗，并为未来扩展奠定基础。

      2. **The Surge（激增）**  
            - 目标是 **提高以太坊的交易吞吐量**，主要通过 **Danksharding 和 Rollups（汇总）** 技术。  
            - **EIP-4844（Proto-Danksharding）** 作为过渡阶段，引入“Blob 交易”，降低 Layer 2（如 Arbitrum、Optimism）的成本。

      3. **The Scourge（净化）**  
            - 解决 **MEV（最大可提取价值）** 相关问题，确保网络去中心化和公平性。  
            - 主要目的是减少矿工/验证者对交易排序的操控，并优化以太坊的 **去中心化中立性**。

      4. **The Verge（边界）**  
            - 重点是 **Verkle Trees（弗克尔树）**，优化存储和状态证明。  
            - 使以太坊节点更轻量级，减少存储需求，提高验证效率。

      5. **The Purge（清理）**  
            - 通过删除旧的历史数据，减少以太坊的 **状态膨胀（State Bloat）**，提高节点同步速度和存储效率。

      6. **The Splurge（锦上添花）**  
            - 其他改进和优化，确保以太坊运行更稳定和高效，比如 **EIP-4337（账户抽象）** 以及未来协议改进。
* **客户端多样性** 以太坊客户端多样性对于网络的安全性、去中心化和弹性至关重要。客户端是运行以太坊协议的软件，负责处理交易、验证区块和与其他节点通信。以太坊的客户端可以分为执行层（EL）和共识层（CL）两部分，执行层客户端如 Geth、Nethermind、Besu 和 Erigon，主要处理智能合约执行和账户状态，而共识层客户端如 Prysm、Lighthouse、Nimbus 和 Teku，负责验证区块和参与共识协议。客户端多样性能提高网络安全性，因为如果某个客户端占据主导地位，出现漏洞或遭受攻击时，可能会导致整个网络受损。通过分散使用多个客户端，即使某个客户端出现问题，网络仍能正常运行，从而增强网络的弹性。此外，去中心化程度也依赖于客户端的多样性，避免了单一客户端的集中控制。在现实中，过去以太坊的执行层主要依赖 Geth，而共识层则大多验证者使用 Prysm，导致集中化问题。因此，社区鼓励验证者和开发者选择不同的客户端，增强网络的去中心化和安全性。总的来说，客户端多样性是以太坊网络健康运作的基础。


### 2025.03.12
#### 3th toaday is CL
* **CL共识层组成和运行方式** 
      1. **信标链（Beacon Chain）**：是CL的主要组件，于2020年12月启动，作为PoS共识机制的核心。
      2. **验证者（Validators）**：代替矿工成为网络安全的守护者，需要质押32个ETH才能成为验证者。
      3. **委员会（Committees）**：每个时隙（slot）随机选择的验证者小组，负责对区块进行投票。
      4. **时隙和纪元（Slots and Epochs）**：
           -  每个时隙持续12秒
           -  32个时隙组成一个纪元（约6.4分钟）
           -  每个时隙由一个验证者提议新区块
      5. **证明（Attestations）**：验证者对区块有效性的投票。
      6. **分叉选择算法（Fork Choice Rule）**：用于确定最长合法链，目前使用LMD-GHOST算法。 

* **拜占庭协议在以太坊CL层的应用** 拜占庭容错（Byzantine Fault Tolerance，BFT）在以太坊CL层的多个方面得到应用：
      1. **Casper FFG（Friendly Finality Gadget）**：
        - 这是以太坊使用的BFT共识机制
        - 当区块获得2/3以上验证者的投票时，会被标记为"确认的"（justified）
        - 当一个"确认的"区块的子区块同样被确认后，原区块变为"最终确定的"（finalized）
        - 这保证网络能够容忍最多1/3的恶意或离线节点
      2. **同步委员会（Sync Committees）**：
        - 负责为轻客户端提供更新，使用BFT机制确保信息准确性
        - 每256个纪元（约27小时）更换一次
      3. **RANDAO机制**：
        - 用于生成验证者选择的随机数
        - 设计为抗拜占庭攻击，即使部分参与者是恶意的也能维持随机性
      4. **惩罚机制（Slashing）**：
        - 对违反协议的验证者实施经济惩罚
            - 惩罚恶意行为（如同时为两个冲突区块投票）
            - 这部分解决了拜占庭将军问题中的"叛徒"问题
      5. **分叉选择**：
            - LMD-GHOST算法考虑验证者的投票权重
            -   能够在存在拜占庭节点的情况下仍选择正确的链

### 2025.03.13
#### 4th toaday is EL
* **EL定义** Execution Layer（EL）是以太坊架构中的关键组成部分，负责处理交易和执行智能合约。
* **EL构成部分**
      * **EVM（以太坊虚拟机）：** EVM是执行层的核心组件，负责在以太坊网络上执行智能合约。它提供了一个运行环境，使得智能合约能够以一致且可预测的方式执行。
      * **交易池：** 交易池存储待处理的交易，这些交易由网络中的节点收集，并等待验证和执行。
      * **状态数据库：** 该数据库记录了以太坊网络的当前状态，包括账户余额、智能合约代码和存储等信息。

* **执行层的运作机制：**
      * **接收交易：** 用户发起交易，交易被广播到以太坊网络，并被节点接收到交易池中。
      * **打包交易：** 验证者从交易池中选择交易，打包成区块，并将区块提议给网络。
      * **验证交易：** 验证者验证交易的有效性，包括检查签名、账户余额等。
      * **执行交易：** 通过EVM执行交易，更新状态数据库中的相关信息。
      * **添加区块：** 验证者将验证通过的区块添加到区块链中，完成交易的确认。


* **区块验证**  共识层（CL）通过 `process_execution_payload` 函数验证区块的有效性，并将执行负载发送给执行层（EL）进行进一步验证。执行层通过状态转换函数（STF）执行区块交易，并更新 `StateDB`。验证过程包括检查区块头信息（如 gas 限制变化、EIP-1559 基础费用等）和执行交易。如果交易无效，则整个区块被拒绝。  

* **区块构建**  建区块的过程涉及从交易池（tx pool）获取最高收益的交易，并依次执行直到达到 gas 限制。过程中，若某笔交易无效，会跳过该交易继续执行剩余交易。最终，`Finalize` 函数将所有交易整理成完整区块并返回。交易池按交易费用优先级排序，保证构建者最大化收益。  

* **进一步探讨 STF、EVM 和 P2P 协议**  状态转换函数（STF）在 Geth 中的实现涉及 `newPayload`、`insertBlockWithoutSetHead` 等函数，它们执行区块并持久化区块状态。EVM 运行基于栈机，指令包括算术、位运算、环境信息、控制流、内存等。P2P 协议（devp2p）用于获取历史数据、同步待处理交易，并通过 Snap 同步机制高效获取链上状态，确保数据完整性和正确性。



### 2025.03.14
#### 4th  测试与安全
* **EVM测试**
  * **目的** 确保每个执行客户端（Execution Client）都符合以太坊规范，否则可能导致链的分叉。
      * 以太坊执行层规范（Ethereum Execution Layer Specification）来源：`https://github.com/ethereum/execution-spec-tests`
  * **测试要素**
      * **Pre-state（前置状态）**：描述以太坊链的状态，包括账户余额、nonce、代码和存储。
      * **Environment（环境变量）**：定义区块链状态，如时间戳、前区块哈希值、gas 限制等。
      * **Transaction（交易）**：测试区块链交互，涉及账户信息、交易金额、gas 限制等。
      * **Post-state（后置状态）**：修改或创建账户的最终状态。    
 * **EVM 测试格式**
      * **State Testing（状态测试）**：使用 state root（状态根） 进行验证。
      * **预期结果**：相同的输入应返回相同的 state root
      * **Fuzzy Differential State Testing（模糊差分测试)**：在基础交易上添加 FuzzyVM 生成的智能合约代码，检查所有客户端是否仍能返回相同的 state root。
      * **Blockchain Testing（区块链测试）**：需要完整区块测试（如 EIP-1559 基础费用计算）。
      * **Blockchain Negative Testing（区块链负面测试）**：向区块链添加无效区块，验证客户端是否能正确拒绝，并回溯到正确区块。

* **主要测试网络**

| **测试网**  | **状态** | **共识机制** | **用途** | **启动时间** | **RPC 端点** |
|------------|---------|-------------|----------|--------------|--------------|
| **Sepolia** | ✅ 运行中 | 权益证明（PoS） | **推荐** dApp & 合约测试 | 2021 年 10 月  | `https://ethereum-sepolia.publicnode.com` |
| **Holesky** | ✅ 运行中 | 权益证明（PoS） | **推荐** 验证者、Staking & 共识测试 | 2023 年 9 月 | `https://ethereum-holesky.publicnode.com` |  


### 2025.03.15
#### 5th -又见路线图
**以太坊发展路线图**

以太坊的路线图旨在提升网络的可扩展性、安全性和可持续性，主要包括以下阶段：

1. **合并（The Merge）**：已完成的阶段，将以太坊从工作量证明（PoW）转向权益证明（PoS），提高了网络的能源效率和安全性。

2. **涌现（The Surge）**：目标是通过引入分片技术和改进的Rollup方案，将交易处理能力提升至每秒10万笔以上。

3. **清除（The Purge）**：旨在减少历史数据和技术债务，简化协议，降低节点存储需求，提升网络性能。

4. **飞跃（The Splurge）**：包括各种小的升级和优化，以确保网络的稳定性和性能。

这些阶段并非线性推进，许多改进是并行进行的，具体实施时间可能会根据研究和开发的进展而调整。

**活跃的以太坊研究领域**

以太坊社区积极参与多个研究领域，以持续改进网络功能和性能，主要包括：

1. **共识机制研究**：关注以太坊的权益证明机制，包括识别和修补漏洞、量化加密经济安全性、提高客户端实现的安全性或性能，以及开发轻客户端等。

2. **执行层研究**：涉及交易执行、以太坊虚拟机（EVM）运行和生成执行有效负载等领域。研究内容包括构建轻客户端支持、研究Gas限制以及引入新数据结构（如Verkle树）等。

3. **客户端开发**：将协议研究成果应用于以太坊客户端的开发，包括更新客户端规范和构建具体实现。

4. **零知识证明和加密技术**：零知识证明（ZKP）和加密技术对于构建以太坊及其应用程序的隐私性和安全性至关重要。零知识是一个相对年轻但发展迅速的领域，存在许多开放的研究和开发机会。 citeturn0search1

**Blobspace与数据可用性** 为解决可扩展性问题，以太坊引入了Blobspace的概念，特别是在EIP-4844（Proto-Danksharding）中。Blobspace旨在降低Rollup方案提交数据的成本，从而提高网络的整体可扩展性。 

**以太坊的最终目标** Vitalik Buterin在《Endgame》一文中探讨了高交易吞吐量区块链的去中心化和抗审查性问题，提出了通过分层质押、引入欺诈证明或零知识证明、数据可用性采样以及次级交易通道等方式，确保即使在高交易量的情况下，区块验证仍然是信任最小化和高度去中心化的，同时防止区块生产者进行审查。 

 

### 2025.03.16
#### 6th-spec 规范

* **以太坊共识规范（consensus-specs）**
  * **具体内容**：
      - **共识机制**：详细描述了以太坊权益证明（Proof-of-Stake, PoS）共识机制的规则和协议。
      - **信标链规范**：定义了信标链的结构、状态转换函数、验证规则等。
      - **验证者操作**：规定了验证者的职责、激励和惩罚机制，以及验证者的生命周期管理。
      - **同步协议**：描述了节点之间如何同步区块和状态，以保持网络一致性。
  * **关键要点**：
      - **PoS共识机制**：通过质押以太币，验证者被选中提议和验证区块，取代了工作量证明（PoW）机制。
      - **信标链**：作为以太坊2.0的核心链，协调分片链的共识和跨链通信。
      - **验证者激励**：通过奖励和惩罚机制，确保验证者的诚实行为，维护网络安全性。
  * **规范的意义**：
      - **标准化**：提供了统一的共识协议规范，确保不同客户端实现的一致性。
      - **安全性**：通过明确的规则和验证者管理，增强网络的安全性和可靠性。
      - **可扩展性**：为未来的网络升级和功能扩展奠定基础。

* **以太坊执行层规范（EEL-spec）**
  * **具体内容**：
      - **交易处理**：定义了交易的格式、验证规则和执行逻辑。
      - **智能合约执行**：描述了EVM（以太坊虚拟机）的操作码、执行环境和合约调用机制。
      - **状态管理**：规定了账户模型、存储结构和状态转换函数。
      - **Gas机制**：解释了交易和合约执行的费用计算和Gas限制。
  * **关键要点**：
      - **EVM**：作为以太坊的核心执行环境，负责智能合约的部署和执行。
      - **账户模型**：以太坊采用账户余额和合约存储的状态管理方式。
      - **Gas机制**：通过费用机制，防止资源滥用，确保网络的健康运行。
  * **规范的意义**：
      - **一致性**：确保不同客户端在交易处理和合约执行上的行为一致。
      - **安全性**：通过明确的执行规则，防范潜在的攻击和漏洞。
      - **开发指导**：为客户端开发者和智能合约开发者提供清晰的参考。

* **以太坊执行规范（execution-specs）**
  * **具体内容**：
      - **网络升级**：记录并规范了以太坊各次网络升级（硬分叉）的具体内容和技术细节。
      - **协议变更**：详细描述了每次升级中协议的修改，包括共识规则、EVM改进等。
      - **升级流程**：定义了网络升级的提案、测试和部署流程。
  * **关键要点**：
      - **网络升级**：以太坊通过定期的硬分叉，引入新功能和改进，提升网络性能和安全性。
      - **协议变更**：每次升级都会对协议进行调整，可能涉及Gas成本、操作码行为等方面。
      - **社区协作**：网络升级需要开发者、矿工和用户的共同参与和协作。
  * **规范的意义**：
      - **透明性**：清晰记录协议的演进过程，增强社区信任。
      - **指导性**：为客户端和dApp开发者提供升级参考，确保兼容性。
      - **安全性**：通过规范的升级流程，减少潜在的分叉和网络分裂风险。


### 2025.03.17
#### 7th-Reth client
* **Reth 客户端**
  * **具体内容**：
      - **以太坊执行层（EL）客户端**：Reth 作为 Rust 实现的以太坊执行层客户端，支持 Engine API，与共识层（CL）兼容。
      - **轻量级、高效设计**：Reth 采用 Rust 语言，专注于性能优化，目标是成为最轻量级、最模块化的以太坊节点。
      - **模块化架构**：核心组件可单独使用，开发者可以灵活组合使用不同模块。
      - **自由开源**：采用 Apache/MIT 许可，所有代码和设计均可公开访问和贡献。
  * **关键要点**：
      - **兼容性**：Reth 遵循以太坊协议标准，与主流共识层（CL）客户端无缝配合。
      - **高性能**：借鉴 Erigon 的分阶段同步策略，提高节点运行效率。
      - **模块化**：所有组件均可独立使用，开发者可根据需求自由调整。
  * **客户端的意义**：
      - **促进客户端多样性**：降低以太坊对 Geth、Nethermind 等客户端的依赖，增强网络稳定性。
      - **提高开发灵活性**：为开发者提供灵活的 Rust 组件，支持自定义区块链应用。
      - **优化同步和存储**：减少资源占用，提高节点运行效率。

* **Reth 设计和架构**
  * **具体内容**：
      - **核心架构**：Reth 采用模块化设计，拆分不同功能组件，如数据库存储、EVM 执行、交易池管理等。
      - **存储优化**：使用高效的数据结构（如 MPT、索引优化）来减少磁盘 IO，提高查询效率。
      - **同步模式**：支持从创世块同步、快速同步，以适应不同场景需求。
      - **Rust 生态**：依赖 Alloy、revm 等 Rust 以太坊库，提升代码复用性和安全性。
  * **关键要点**：
      - **模块独立性**：每个组件都可以单独作为库使用，提高可维护性和扩展性。
      - **性能优化**：利用 Rust 的并发特性和内存安全机制，提升执行效率。
      - **高可用性**：优化存储和网络传输，降低运行成本，提高可靠性。
  * **架构的意义**：
      - **增强可维护性**：模块化架构便于开发者维护和扩展功能。
      - **提高效率**：优化存储和同步方式，提升以太坊节点运行性能。
      - **支持多样化应用**：可作为全节点、轻节点或离线数据索引器使用。

* **Reth 代码库概述、示例**
  * **具体内容**：
      - **GitHub 代码库**：[Reth GitHub](https://github.com/paradigmxyz/reth) 提供完整的 Rust 代码实现。
      - **核心模块**：
          - `reth-node`：完整的 Reth 节点实现，负责区块同步、交易处理等功能。
          - `reth-db`：存储模块，提供高效的数据库存储解决方案。
          - `reth-primitives`：封装了区块、交易、状态等基本数据结构。
          - `reth-network`：管理以太坊 P2P 网络连接，处理数据同步和消息传递。
      - **示例代码**：
          ```rust
          use reth_node::NodeConfig;
          fn main() {
              let config = NodeConfig::default();
              println!("Reth 节点配置: {:?}", config);
          }
          ```
  * **关键要点**：
      - **代码结构清晰**：核心模块独立，便于扩展和修改。
      - **Rust 生态整合**：充分利用 Rust 语言的安全性和性能优势。
      - **开发者友好**：提供详细的文档和示例，方便开发者快速上手。
  * **代码库的意义**：
      - **提供完整实现**：让开发者可以直接运行 Reth 节点，或基于其代码进行二次开发。
      - **支持模块化使用**：开发者可选择性地使用 Reth 的某些组件，而不必运行完整节点。
      - **提升 Rust 以太坊生态**：为 Rust 开发者提供高质量的以太坊客户端代码库。

* **Reth 的特点和亮点**
  * **具体内容**：
      - **高效同步**：采用优化的分阶段同步策略，减少存储占用和数据处理时间。
      - **轻量级设计**：相比 Geth 和 Erigon，Reth 的存储和计算开销更低。
      - **模块化开发**：所有核心功能均可独立使用，支持不同应用场景的定制开发。
      - **开源透明**：代码完全开源，任何人都可以审查、修改和贡献。
  * **关键要点**：
      - **速度快**：优化同步和数据库访问，提高节点启动和运行效率。
      - **存储优化**：减少磁盘占用，降低存储成本，提高数据检索性能。
      - **灵活扩展**：可用于全节点、轻客户端或定制区块链应用。
  * **特点的意义**：
      - **提升以太坊生态**：提供更高效的客户端，实现网络去中心化。
      - **降低运行成本**：减少存储和计算资源占用，提高运营效率。
      - **支持创新**：开发者可以利用 Reth 的模块进行更多 Web3 应用开发。

### 2025.03.18
#### 8th-Teku CL client

* **Teku CL 客户端概述**
  * **具体内容**：
      - **GitHub 代码库**：[Teku GitHub](https://github.com/ConsenSys/teku) 提供完整的 Java 代码实现。
      - **核心模块**：
          - `beacon-chain`：实现信标链的核心逻辑，包括区块处理、状态管理和验证者职责。
          - `validator-client`：管理验证者的签名、密钥处理和提案任务。
          - `networking`：处理 P2P 网络通信，管理 Libp2p 连接。
          - `storage`：提供持久化存储，支持数据库备份和恢复。
      - **示例代码**：
          ```java
          public class TekuExample {
              public static void main(String[] args) {
                  System.out.println("Teku 客户端示例运行成功！");
              }
          }
          ```
  * **关键要点**：
      - **模块化架构**：各核心模块独立，便于扩展和维护。
      - **Java 生态整合**：利用 Java 语言的稳定性和可移植性。
      - **企业级支持**：由 ConsenSys 维护，适用于机构级 Staking 需求。
  * **代码库的意义**：
      - **提供完整的共识层实现**：支持以太坊 2.0 验证者运行和网络同步。
      - **支持模块化使用**：开发者可灵活组合 Teku 的各组件。
      - **提升以太坊 PoS 生态**：助力共识层客户端的多样化，增强网络安全性。

* **REST API 声明式框架**
  * **具体内容**：
      - **Teku 提供 REST API，方便开发者远程访问信标链数据。**
      - **核心 API 端点**：
          - `/eth/v1/beacon/blocks`：获取最新信标链区块信息。
          - `/eth/v1/validator/duties`：查询验证者的职责。
          - `/eth/v1/node/identity`：获取节点身份信息。
  * **关键要点**：
      - **标准化 API 设计**，便于集成和扩展。
      - **提供 OpenAPI 文档**，简化开发者对接流程。
      - **适用于 Staking 运营商**，可远程监控和管理验证者。

* **开发流程一瞥：EIP -> Spec -> Code**
  * **具体内容**：
      - **Ethereum 改进提案（EIP）流程**：
          1. **EIP 提出**：社区成员提出新特性（如 EIP-7251）。
          2. **规范（Spec）制定**：编写详细技术规范，确保一致性。
          3. **代码实现**：共识层客户端（如 Teku）根据 Spec 进行开发。
  * **关键要点**：
      - **规范化开发流程**：确保协议改进的一致性和可行性。
      - **社区驱动**：开发者和研究人员共同维护。
      - **测试与审计**：确保改动不会影响网络稳定性。

* **EIP-7251（maxEB） 示例**
  * **具体内容**：
      - **EIP-7251 提出 `maxEB`（最大有效区块）的概念**：
          - 允许共识客户端调整最大区块大小，提高吞吐量。
          - 影响区块验证逻辑，使其适应不同的网络环境。
      - **Teku 代码实现**：
          - 增加 `maxEB` 配置项，允许用户调整区块大小。
          - 变更信标链状态处理逻辑，使其兼容动态区块大小。
  * **关键要点**：
      - **提高网络扩展性**：适应不同 Staking 运营需求。
      - **灵活的区块大小控制**，优化链上交易处理。
      - **与现有共识逻辑兼容**，不会影响安全性。

* **信标 API**
  * **具体内容**：
      - **信标 API（Beacon API）提供访问以太坊 2.0 信标链数据的能力。**
      - **主要端点**：
          - `/eth/v1/beacon/states`：获取信标链最新状态。
          - `/eth/v1/validator/attestations`：查询验证者的证明数据。
          - `/eth/v1/node/peers`：获取当前 P2P 连接的节点列表。
  * **关键要点**：
      - **提供统一的 API 访问方式**，兼容不同客户端（Teku、Lighthouse）。
      - **支持数据监控和分析**，方便 Staking 运营商优化策略。
      - **适用于自动化管理**，降低人工干预成本。

* **Lighthouse 共识客户端架构**
  * **具体内容**：
      - **Lighthouse 是 Rust 实现的共识层客户端，与 Teku 类似**。
      - **架构特点**：
          - **模块化设计**：独立的信标链、P2P 网络、存储等组件。
          - **高效性能优化**：Rust 语言特性提升吞吐量和资源利用率。
          - **轻量级实现**：适用于资源受限的环境。
  * **关键要点**：
      - **与 Teku 形成对比**，展示 Java 与 Rust 在共识客户端中的应用差异。
      - **强调安全性与高效性**，适合不同以太坊 2.0 参与者。
      - **共识层的多样性**，增强网络稳定性和去中心化。

* **贡献者的 Teku 代码约定**
  * **具体内容**：
      - **代码风格**：
          - 遵循 Java 最佳实践，代码清晰、易维护。
          - 使用 `Checkstyle` 和 `SpotBugs` 进行静态分析。
      - **开发流程**：
          - 提交 PR 需通过 CI 测试。
          - 变更需要完整的单元测试和集成测试。
  * **关键要点**：
      - **维护高质量代码**，提高可读性和可维护性。
      - **CI/CD 自动化**，确保代码合规性。
      - **友好的贡献流程**，降低新开发者的学习成本。

* **Teku 与合并，PEEPanEIP#83**
  * **具体内容**：
      - **以太坊合并（The Merge）**：
          - Teku 作为共识层客户端，确保以太坊从 PoW 过渡到 PoS。
          - 需要与 Execution 层（如 Geth）保持同步。
      - **PEEPanEIP#83**：
          - 讨论 Teku 适配 The Merge 的过程。
          - 影响共识规则变更、状态转换和交易验证等关键技术点。
  * **关键要点**：
      - **Teku 在以太坊合并中的核心作用**，确保 PoS 过渡顺利。
      - **与 Execution 层的交互优化**，提升网络运行效率。
      - **技术社区的广泛参与**，推动以太坊协议的演进。

### 2025.03.19
#### 9th-kurtosis
* **安装kurtosis CLI**
```
echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
sudo apt update
sudo apt install kurtosis-cli
```

* **本地测试**
    * 启动本地开发网络(my-testnet为网络命名)：
        ```
        kurtosis run --enclave my-testnet github.com/ethpandaops/ethereum-package

        ```
    * 访问服务Shell：
        ```
        kurtosis service shell my-testnet el-1-geth-lighthouse

        ```
    * 连接到 Geth 控制台:
        ```
        geth --datadir /data/geth/execution-data/ attach

        ```
    * 监听区块信息
        ```
        var filter = eth.filter('latest');
        filter.watch(function(error, result) {
            if (!error) {
                var block = eth.getBlock(result, true);
                console.log(block);
            }
        });
        ```
* **常用命令**

  * **引擎管理**
    * `kurtosis engine status`：查看当前 Kurtosis 引擎的状态。
    * `kurtosis engine logs`：查看 Kurtosis 引擎的日志。
    * `kurtosis engine start`：启动 Kurtosis 引擎。
    * `kurtosis engine stop`：停止 Kurtosis 引擎。
    * `kurtosis engine clean`：清理所有环境和关联资源，并停止引擎。

  * **环境管理**
    * `kurtosis run <package>`：通过 GitHub URL 或本地路径启动指定的包。
    * `kurtosis enclave rm -f <enclave-name>`：删除指定名称的环境及其资源。
    * `kurtosis clean -a`：清理所有环境和资源。

  * **服务管理**
    * `kurtosis service shell <enclave-name> <service-name>`：获取服务的 shell 访问权限。
    * `kurtosis service logs <enclave-name> <service-name>`：查看服务的日志。

### 2025.03.20
#### 10th-Pre-reading
* **定义** 以太坊虚拟机（EVM）预编译合约是部署在特定地址上的原生合约，旨在提供高效的底层功能，如加密操作。这些合约直接在EVM中实现，以提高性能并降低复杂性。

* **预编译合约的集成方式** 预编译合约在EVM中以固定地址存在，通常从`0x1`到`0x8`，每个地址对应一个特定功能。例如，`0x1`地址对应椭圆曲线数字签名算法的公钥恢复功能（`ecrecover`），`0x2`地址对应SHA-256哈希函数。这些合约在EVM内部实现，开发者可以通过调用这些固定地址来使用相应功能。 

* **现有的预编译合约** 根据EVM的规范，以下是一些常见的预编译合约及其对应功能：
    - `0x1`：`ecrecover`，用于从签名中恢复公钥。
    - `0x2`：`sha256`，计算SHA-256哈希值。
    - `0x3`：`ripemd160`，计算RIPEMD-160哈希值。
    - `0x4`：`identity`，返回输入数据本身。

* **L1和L2对预编译合约的使用** 在以太坊第一层（L1）上，预编译合约被广泛用于执行复杂的加密操作，以提高效率并降低计算成本。在第二层（L2）解决方案中，预编译合约同样扮演重要角色。例如，Optimism的Bedrock升级中，L2账户可以通过调用预部署的Message Passer合约与L1合约交互，实现ETH从L2到L1的转移。 

### 2025.03.21
#### 11th-DAS
* **以太坊可扩展性**
    * **具体内容**
        - **以太坊的扩展性挑战**：
            - 计算能力受限，所有交易需由全网节点验证，导致吞吐量低。
            - 存储负担大，随着区块链增长，全节点存储需求持续增加。
            - 去中心化与扩展性的权衡，直接增加区块大小可能影响去中心化。
        - **扩展方案**：
            - **Layer 2 方案**：如状态通道（State Channels）、Rollups（Optimistic Rollup 和 ZK-Rollup）。
            - **分片（Sharding）**：以太坊 2.0 主要扩展方案，通过拆分多个并行处理的分片链提升性能。
    * **关键要点**
        - **以太坊目前面临扩展性瓶颈，需要更高的吞吐量支持去中心化应用（DApp）。**
        - **分片技术与 Layer 2 方案相结合，提高交易处理效率，同时保持去中心化和安全性。**
        - **Danksharding 方案的引入，进一步优化 Rollups 依赖的数据存储，降低 Layer 2 交易成本。**

* **分片的历史和前进的道路**
    * **具体内容**
        - **早期分片方案**：
            - 参考传统数据库的分片概念，计划将计算、存储、交易执行拆分到多个分片链。
            - 早期架构较复杂，跨分片交易同步困难。
        - **分片架构的演变**：
            - **早期设计（2018 年前后）**：
                - 采用多层分片架构，每个分片链有独立的状态、交易和验证者。
            - **以太坊 2.0（2020-2022 年）**：
                - 引入 **信标链（Beacon Chain）** 作为协调者，管理验证者和随机分片分配。
                - 逐步从 **计算分片（State Execution Sharding）** 转向 **数据分片（Data Availability Sharding）**。
            - **当前发展（2023+）**：
                - 采用 **Danksharding** 方案，重点提升数据可用性，支持 Rollups 进行交易执行。
                - 通过 **Proto-Danksharding（EIP-4844）** 作为过渡方案，引入“Blob 交易”优化存储。
    * **关键要点**
        - **以太坊分片架构经历了从计算分片到数据分片的演变，以适应 Layer 2 发展。**
        - **信标链作为核心协调层，确保分片的安全性和验证者管理。**
        - **Danksharding 通过数据分片优化存储和处理能力，结合 Rollups 提升吞吐量。**

* **数据可用性**
    * **具体内容**
        - **数据可用性问题**：
            - 如何确保分片区块的数据完整且可访问，即使部分节点离线或作恶。
            - 传统方案需要全节点存储所有数据，但这会影响扩展性。
        - **解决方案**：
            - **数据可用性采样（DAS）**：
                - 允许轻客户端只检查部分数据，利用概率机制检测数据完整性。
                - 结合 **Erasure Coding（纠删码）**，即使部分数据丢失，也能恢复完整信息。
            - **KZG 证明（Kate-Zaverucha-Goldberg Commitments）**：
                - 通过数学证明，确保数据完整性，无需所有验证者存储完整数据。
            - **Danksharding 方案**：
                - 采用 **Blob 交易** 存储 Rollup 交易数据，减少以太坊主链存储负担。
                - 轻客户端可利用 KZG 证明和 DAS 验证数据，而无需下载完整数据。
    * **关键要点**
        - **数据可用性是分片架构的核心问题，影响整个以太坊 2.0 的安全性和扩展性。**
        - **数据可用性采样（DAS）结合 KZG 证明，实现高效的数据完整性验证。**
        - **Danksharding 通过优化数据存储方式，使 Layer 2 方案更加高效，降低 Rollups 交易成本。**

### 2025.03.22
#### 12th-Verkle Trees
* **The Verge：以太坊的未来阶段**
    * **动机和好处**
        - **动机**：采用 Verkle 树的主要动机是实现无状态客户端，使节点无需存储完整状态即可验证交易，从而降低硬件要求，促进网络的去中心化。
        - **好处**：
            - **减少证明大小**：相比传统的 Merkle Patricia 树，Verkle 树的证明大小更小。例如，对于包含 10 亿个数据对象的树，传统 Merkle 树的证明大小约为 1 KB，而 Verkle 树的证明仅需不到 150 字节。
            - **提高验证效率**：更小的证明尺寸和更高效的验证过程，有助于提升网络性能。

* **Verkle 密码学**
    - **Verkle 树**：基于多项式承诺的树形结构，支持高效的证明和验证操作。与传统的 Merkle Patricia 树不同，Verkle 树使用多项式承诺来替代哈希函数，从而实现更小的证明尺寸和更快的验证速度。

* **数据结构**
    - **向量承诺（Vector Commitments）**：
        - 允许存储在 Verkle 树中的数据被高效地验证，而无需下载整个树。
        - 通过多项式承诺确保数据完整性，并减少存储和计算成本。

* **Gas 定价**
    - **影响**：引入 Verkle 树可能影响以太坊的 Gas 定价模型。由于状态访问和修改的成本可能降低，Gas 费用可能需要重新评估，以反映更高效的状态操作。这有助于提高交易处理效率，降低用户成本。

* **将状态树转换为 Verkle**
    - **转换过程**：将以太坊现有的 Merkle Patricia 树转换为 Verkle 树需要进行状态迁移。这包括重新构建状态树，并确保所有节点和客户端能够兼容新的数据结构。

* **现状和挑战**
    - **现状**：截至目前，Verkle 树的研究和开发仍在进行中。
    - **挑战**：
        - **兼容性**：确保现有客户端和基础设施与新的数据结构兼容。
        - **安全性**：验证新结构的安全性，防止潜在漏洞。
        - **性能优化**：在实际应用中优化 Verkle 树的性能，以满足以太坊网络的需求。

* **总结**
    - Verkle 树通过减少状态证明大小，提高验证效率，使无状态客户端成为可能。
    - 未来以太坊将从 Merkle Patricia 树迁移到 Verkle 树，以降低存储需求并优化 Gas 费用。
    - 仍需解决兼容性、安全性和性能优化等挑战，以确保平稳过渡。

### 2025.03.23
#### 13th-MEV
* **以太坊中的 MEV、协议服务及其影响**

    * **最大可提取价值（MEV）**
        - 最大可提取价值（MEV）指的是区块生产者通过在区块中包含、排除或重新排序交易，所能提取的超出标准区块奖励和 Gas 费用的最大价值。
        - 在以太坊从工作量证明（PoW）转向权益证明（PoS）后，验证者取代矿工，负责交易的包含和排序。然而，MEV 的提取方式依然存在，可能导致抢先交易、交易费用增加等问题，影响网络公平性和用户体验。

    * **提议者与构建者分离（PBS）及相关提案**
        - **提议者与构建者分离（PBS）** 是一种提高以太坊网络可扩展性和安全性的机制。核心思想是将区块提议者和区块构建者的职责分离，分别负责提议新区块和构建区块内容。
        - **嵌入式提议者与构建者分离（ePBS）**（EIP-7732）进一步将 PBS 机制直接集成到以太坊协议中，减少对第三方服务的依赖，优化区块验证过程，提高网络性能。

    * **MEV 烧伤**
        - MEV 烧伤是一种通过将部分 MEV 收益销毁来减少其负面影响的机制。
        - 该机制旨在降低验证者过度追求 MEV 的动机，维护网络公平性。然而，具体实施方案和效果仍在研究和讨论中。

    * **彩虹质押**
        - 彩虹质押是一种多元化质押策略，允许验证者在不同的协议和链上分散其质押资产，以降低风险并提高收益。
        - 这种方法有助于增强网络的去中心化程度和安全性。

    * **分片的历史和前进的道路**
        * **早期分片方案**
            - 参考传统数据库的分片概念，计划将计算、存储、交易执行拆分到多个分片链。
            - 由于架构复杂，跨分片交易的同步存在困难。

        * **分片架构的演变**
            - **早期设计（2018 年前后）**：
                - 采用多层分片架构，每个分片链拥有独立的状态、交易和验证者。
            - **以太坊 2.0（2020-2022 年）**：
                - 随着研究的深入，分片设计逐渐简化，强调数据可用性和跨分片通信的效率，旨在提高网络的可扩展性和用户体验。

### 2025.03.24
#### 14th-Portal
* **历史数据过期（History Expiry）**
    - 历史数据过期允许节点删除它们不太可能需要的旧数据，只保留少量历史数据。这意味着节点在同步和服务数据请求时，只需处理最新的数据块，从而减少存储需求。然而，这也带来了需要从网络中其他节点请求已删除数据的挑战。为此，开发了门户网络（Portal Network），旨在通过点对点网络分发历史数据，使轻节点能够在无需信任全节点的情况下访问所需的数据，同时减轻全节点的负担。

* **状态数据过期（State Expiry）**
    - 状态数据过期使得不经常使用的状态数据变为非活动状态。这些非活动数据可以在需要时重新激活。这种方法有助于减少节点需要存储的活跃状态数据量，从而降低存储需求。与历史数据过期类似，状态数据过期也需要解决如何高效访问非活动数据的问题。

* **弱无状态性（Weak Statelessness）**
    - 弱无状态性意味着只有区块生产者需要访问完整的状态数据，而其他节点可以在没有本地状态数据库的情况下验证区块。这进一步减少了节点的存储和计算需求。然而，这要求区块生产者能够高效地访问完整的状态数据，并确保网络中的其他节点能够验证区块的有效性。

* **强无状态性（Strong Statelessness）**
    - 强无状态性是无状态性的最终形式，其中没有节点需要访问完整的状态数据。所有节点都可以在没有本地状态存储的情况下验证区块和交易。这种方法最大程度地减少了节点的存储和计算需求，但也面临着如何高效处理交易和区块验证的挑战。

* **以太坊改进提案（EIP）标准**
    - 以太坊改进提案（EIP）是对以太坊协议进行修改或扩展的建议。每个EIP都有一个状态，表示其当前的开发和审查阶段。常见的状态包括：
        - **草案（Draft）**：提案正在开发中，等待进一步的审查和讨论。
        - **审查（Review）**：提案已准备好进行同行评审。
        - **最后一次通告（Last Call）**：提案进入最后审查阶段，通常持续14天。
        - **最终（Final）**：提案已被接受为正式标准。
        - **停滞（Stagnant）**：提案在草案、审查或最后通告阶段超过6个月没有活动，将被标记为停滞。
    - 此外，还有一些其他状态，如**撤销（Withdrawn）**，表示提案已被作者或社区撤回；**生效（Living）**，表示提案已永久生效，如EIP-1；**过时（Obsolete）**，表示提案已被其他提案取代。

* **过时的EIP标准**
    - 随着以太坊的发展，一些早期的EIP可能已被新的提案取代或不再适用。例如，EIP-233曾建议将硬分叉管理和规范管理分开，但这一提案已被新的流程所取代。要查看当前有效的EIP列表，可以访问以太坊官方的EIP存储库。

### 2025.03.25
#### 15th-SSF
* **Gasper 回顾**  
  * Gasper 是以太坊 2.0 信标链采用的权益证明共识协议的理想化版本。  
  * 它结合了 Casper FFG（最终确定性工具）和 LMD GHOST（分叉选择规则），旨在平衡区块链的安全性和效率。  
  * 设计目标是提供中等的最终确定时间、中等的链负载和中等的节点数量，以适应以太坊网络的需求。  

* **Gasper 的问题和修复**  
  * **用户体验**：当前区块需要约 15 分钟才能最终确定，用户不愿等待如此长时间。  
  * **复杂性**：混合机制增加了协议的复杂性，可能引入安全漏洞。  
  * **短期重组风险**：在最终确定之前，区块链可能发生短期重组，影响网络稳定性。  
  * **修复方案**：提出单时隙最终确定性（SSF）等改进方案，旨在减少最终确定时间，提高用户体验和网络安全性。  

* **单时隙最终确定性（SSF）**  
  * SSF 指在一个时隙内完成区块的提议和最终确定，避免当前约 15 分钟的延迟。  
  * 实现 SSF 需要在去中心化、时间和计算资源之间进行权衡。  
  * 通过优化认证处理方式，可以在不增加每个节点计算负担的情况下，实现更快的最终确定。  
  

* **分叉选择如何影响其他以太坊升级：PeerDAS 和 ePBS 案例研究**  
  * 分叉选择规则对以太坊的其他升级，如 PeerDAS 和 ePBS，有重要影响。  
  * 这些升级旨在提高数据可用性和区块提议的效率，需要与现有的分叉选择机制兼容。  
  * 在设计这些升级时，必须考虑分叉选择规则的特性，以确保网络的整体性能和安全性。  

### 2025.03.26
#### 16th-Gasper
* **Fork Choice 简介**
  * 在区块链中，分叉选择规则用于在出现多个链分叉时确定哪条链是规范链。以太坊的信标链采用了特定的分叉选择算法来确保网络的一致性和安全性。

* **LMD GHOST**
  * LMD GHOST（Latest Message-Driven Greedy Heaviest Observed Sub-Tree）是一种分叉选择算法。它通过选择具有最大证明累积权重的分叉作为规范链来运作。具体而言，该算法仅考虑每个验证者的最新投票（最新消息驱动），并选择最重的子树作为主链。citeturn0search0

* **Casper FFG**
  * Casper FFG（Friendly Finality Gadget）是以太坊引入的一种最终确定性机制。它通过两步投票过程来实现区块的最终确定性：
    1. 一个区块必须获得总质押以太币三分之二的投票，才能被视为“合理”区块。
    2. 当一个合理区块上有另一个区块被合理化时，前者被升级为“最终确定”状态。citeturn0search0

  * 此机制确保了区块链的安全性，即除非攻击者控制或销毁大量质押的以太币，否则最终确定的区块不会被回滚。

* **Gasper**
  * Gasper 是将 LMD GHOST 分叉选择算法与 Casper FFG 最终确定性机制相结合的共识协议。它结合了两者的优势，确保了以太坊权益证明区块链的安全性和活性。Gasper 定义了验证者如何受到奖励和惩罚，决定了接受和拒绝哪些区块，以及在区块链分叉上如何构建区块。

### 2025.03.27
#### 17th-EVM
* **以太坊状态转换**
  以太坊的状态转换过程由交易驱动，每笔交易都会修改全局状态。以太坊使用账户模型（而非UTXO模型），账户分为外部拥有账户（EOA）和合约账户（CA）。状态转换包括：
  - 验证交易签名
  - 计算交易费用并调整账户余额
  - 执行合约代码（如果涉及智能合约）
  - 更新全局状态（账户余额、存储等）

* **EVM**
  以太坊的核心是以太坊虚拟机（EVM），它是一个图灵完备的沙盒环境，运行智能合约的字节码。EVM 通过一系列操作码（opcodes）执行计算，并维护栈、内存和存储。

* **Ethereum 虚拟机**
  EVM 运行在所有以太坊节点上，负责处理交易、执行智能合约。主要特点：
  - 基于堆栈的执行模型
  - 256 位字长（适用于加密计算）
  - 访问权限控制（合约存储、外部合约调用）
  - 采用 gas 机制防止滥用计算资源

* **内部呼叫**
  在 EVM 中，智能合约可以调用其他合约，称为内部调用（internal call）。内部调用主要方式：
  - `CALL`：普通调用，可修改状态
  - `DELEGATECALL`：调用另一个合约，但使用调用者的存储
  - `STATICCALL`：只读调用，不允许修改状态

* **GAS计量**
  EVM 使用 Gas 作为计算资源的度量单位，以防止无限循环和滥用。主要规则：
  - 每条指令消耗不同数量的 Gas
  - 存储、合约创建等操作消耗大量 Gas
  - 交易费用 = Gas 消耗 * Gas 价格
  - 未使用的 Gas 会退还给发送者

* **EVM 对象格式（EOF）简介**
  EVM 对象格式（EOF）是改进 EVM 执行模型的提案，旨在提高代码结构化、优化性能：
  - 规范合约字节码的结构
  - 提供更好的静态分析能力
  - 限制不安全操作（如 SELFDESTRUCT）
  - 可能引入新的验证规则以提升安全性

* **EVM 中的控制流**
  EVM 通过操作码控制代码执行流程，主要包括：
  - `JUMP` 和 `JUMPI`（条件跳转）
  - `CALL` 和 `RETURN`（合约调用与返回）
  - `STOP`、`REVERT`、`SELFDESTRUCT` 终止合约执行
  - EVM 执行时，每个指令会影响栈、内存或存储，从而改变合约状态

### 2025.03.28
#### 18th-devp2p

* **EL 网络（EL networking）**
  EL 网络指以太坊的执行层（Execution Layer）网络架构，负责处理交易执行和智能合约的状态管理。在以太坊的分层架构中，执行层与共识层（Consensus Layer）协同工作，共同维护网络的正常运行。

* **devp2p 规范（devp2p specs）**
  devp2p 是以太坊的点对点（P2P）网络协议集合，定义了以太坊节点之间的通信方式。该规范包括多个低层协议，如 RLPx（负责加密和多路复用）、节点发现协议 v4 和 v5（用于节点发现）等。此外，devp2p 还定义了多个基于 RLPx 的应用层协议，如以太坊线协议（eth/68）、轻客户端协议（les/4）等。  


* **以太坊节点记录（ENR）**
  以太坊节点记录（Ethereum Node Records，ENR）是用于描述以太坊网络中节点信息的可扩展格式。每个 ENR 包含节点的公钥、IP 地址、端口等信息，并通过签名进行验证。ENR 提供了一种通用且向前兼容的结构，用于传递节点的元数据，支持通过多种渠道（如 DNS）传播节点信息。  

* **节点发现协议 v5（Discv5）**
  节点发现协议 v5（Discv5）是以太坊网络中用于节点发现的协议，基于 UDP 运行，旨在提高节点发现的效率和灵活性。Discv5 支持自认证的灵活节点记录（ENR）和基于主题的广告功能，满足以太坊网络的需求。  

* **子协议（Subprotocols）**
  子协议是构建在 devp2p 之上的应用层协议，定义了特定功能的通信方式。以太坊的子协议包括以太坊线协议（eth/68），用于区块和交易的传播；轻客户端协议（les/4），支持轻量级客户端访问区块链数据；快照协议（snap/1），用于区块链状态的同步等。这些子协议通过扩展 devp2p，实现了以太坊网络的多样化功能。  


### 2025.03.29
#### 19th-libp2p
* **CL 网络协议**  
  CL 网络协议主要指 libp2p 中用于连接建立、管理和升级的底层协议。它负责协调握手、加密和多路复用等关键环节，使得多个子协议能够在单一连接上共存，从而实现安全、稳定和高效的点对点通信。

* **libp2p**  
  libp2p 是一个模块化的点对点网络协议栈，由多个独立但互相协作的协议组成。它提供地址管理、节点发现、连接管理、安全传输、多路复用以及发布/订阅等功能，是构建去中心化应用的基础工具。通过抽象和分层设计，libp2p 能够适应各种网络环境和应用需求。

* **Yamux**  
  Yamux（Yet Another Multiplexer）是一种流多路复用协议，用于在单一传输连接上承载多个逻辑流。它设计简单高效，支持动态创建和关闭流，并具备流量控制和错误恢复功能，从而提高了连接的利用率和整体传输效率。

* **Noise**  
  Noise 是基于 Noise 协议框架的加密握手协议，主要用于在通信双方之间建立安全且经过认证的加密通道。其设计简洁且高性能，采用了现代密码学技术，确保数据在传输过程中的机密性和完整性，是 libp2p 中的重要安全协议之一。

* **GossipSub**  
  GossipSub 是 libp2p 实现的发布/订阅协议，采用基于 Gossip 的消息传播机制。它将推送和拉取相结合，通过节点之间的随机连接来高效分发消息，同时具备消息验证、节点评分和自适应传播策略，能够在大规模分布式网络中实现可靠且可扩展的消息传递。
* **exp code**
```
// 示例1：创建一个基本的 libp2p 节点，使用 TCP 传输、Noise 加密和 Yamux 多路复用

import Libp2p from 'libp2p'
import TCP from 'libp2p-tcp'
import { NOISE } from 'libp2p-noise'
import Yamux from 'libp2p-yamux'

const createLibp2pNode1 = async () => {
  const node = await Libp2p.create({
    addresses: {
      // 监听所有 IP，TCP 端口由系统自动分配
      listen: ['/ip4/0.0.0.0/tcp/0']
    },
    modules: {
      transport: [TCP],
      connEncryption: [NOISE],
      streamMuxer: [Yamux]
    }
  })
  await node.start()
  console.log('节点启动成功，监听地址：', node.multiaddrs.map(addr => addr.toString()))
  return node
}

;(async () => {
  const node1 = await createLibp2pNode1()
  // 节点启动后，可通过 node1 进行拨号或接收连接
})()
```
### 2025.03.30
#### 20th-Validator
* **Validator Client**
  - Validator客户端是以太坊信标链网络中的核心组件，主要负责与其他节点进行数据交换和共识信息的传递。
  - 它运行在节点上，通过处理网络中的区块、执行验证任务来确保链上数据的一致性和安全性。
  - 客户端通常集成了对密钥管理和远程签名的支持，以保障签名操作的安全与高效。
* **Validator Service Initialization**
  - 服务初始化阶段主要包括系统配置、网络连接以及密钥加载等工作，确保验证者能够正确接入信标链网络。
  - 在初始化过程中，会完成验证者密钥的解密与加载，配置远程签名API，并建立与其他网络节点的通信连接。
  - 同时，客户端会执行自检和同步校验，确保所有组件正常运行，以便在后续工作中及时响应网络共识事件。

* **Keystore Management**
  - 密钥库管理是验证者操作中的关键环节，涉及验证者私钥的生成、加密存储与安全调用。
  - 通过采用加密的keystore文件和远程签名API，可以将私钥与签名操作隔离开来，从而降低密钥泄露风险。
  - 此外，密钥管理还要求定期备份和更新，加上对异常访问的监控，确保整个签名过程始终处于受控安全的环境中。

* **Performing Validator Duties**
  - 执行验证者职责包括区块提议、区块验证和参与共识过程，是维护网络稳定与安全的基础工作。
  - 验证者在每个周期内需要按时签署区块和提交验证信息，确保网络中产生的共识数据正确无误。
  - 同时，验证者需要关注激励和惩罚机制，积极响应网络状态变化，避免因延迟或错误操作导致的经济损失。

### 2025.03.31
#### 21th-Engine API
* **Engine API 的设计空间与历史**

  Engine API 是以太坊节点中执行层（EL）与共识层（CL）之间的通信接口。自合并（The Merge）以来，该 API 成为以太坊架构中至关重要的组成部分，负责协调区块验证和区块提议等关键任务。理解其设计空间和演变历史，有助于深入掌握以太坊的运行机制。

  * **设计空间**  
    - Engine API 的设计经历了从最小功能集到复杂功能的渐进式扩展。  
    - 初始设计包括基本的方法，如 `engine_preparePayload` 和 `engine_getPayload`，用于通知执行客户端即将需要提议区块，并在适当时机获取执行有效负载。  
    - 随着需求增加，引入了异步处理、一致性检查点等机制，以增强 API 的扩展性和可靠性。  
    - 例如，`engine_consensusStatus` 和 `engine_executionStatus` 方法用于在启动时进行一致性检查，确保执行层和共识层的区块树保持一致。  

  * **历史演变**  
    - 在合并之前，执行层和共识层的通信相对简单。  
    - 随着以太坊从工作量证明（PoW）过渡到权益证明（PoS），需要更复杂的交互。  
    - Engine API 的开发旨在满足这一需求，提供了一个标准化的接口，支持两层之间的高效通信。  

* **执行层客户端在导入区块时的行为**

  执行层客户端在导入区块时，需要与共识层客户端紧密协作，确保区块的有效性和链的连续性。以下是关键步骤：

  * **启动阶段**  
    - 当启动信标节点时，CL 会调用 EL 的 `engine_exchangeCapabilities` 和 `engine_forkchoiceUpdatedV2` 方法，交换支持的 Engine API 方法，并更新 EL 的分叉选择状态。  

  * **区块构建**  
    - 当验证者被选中提议区块时，CL 调用 EL 的 `engine_forkchoiceUpdatedV2` 方法，传递 `ForkchoiceState` 和 `PayloadAttributes`，启动有效负载构建过程。  
    - 随后，CL 调用 `engine_getPayloadV2` 获取构建的 `execution_payload`，将其整合到信标区块中，并计算 `state_root`，最终传播区块。  

  * **乐观同步**  
    - 在某些情况下，EL 可能会以“乐观”方式导入区块，即在尚未完全验证执行有效负载的情况下，暂时接受区块。  
    - 这种方式允许链的快速推进，但需要在后台继续验证有效负载的有效性。  
    - 如果稍后发现有效负载无效，必须回滚相关区块，并通知 CL。  

  * **错误处理**  
    - 如果 EL 在处理 `engine_forkchoiceUpdatedV2` 或 `engine_newPayloadV2` 时遇到错误，例如引用的有效负载无效，EL 会返回相应的错误状态。  
    - CL 需要根据这些状态采取适当的措施，如重新同步或调整分叉选择。  

  执行层客户端在导入区块时，遵循严格的验证和同步机制，与共识层客户端协同工作，确保以太坊网络的安全和稳定运行。

### 2025.04.01
#### 22th-CL Data
* **CL DATA**
  * **概述**
    * CL DATA是指以太坊共识层（Consensus Layer）的数据结构和相关信息。
  * **Beacon State**
    * **定义**
      * Beacon State是以太坊2.0中Beacon链的状态，包含链的当前状态信息。
    * **组成部分**
      * **状态根（State Root）**
        * 状态的哈希根，用于验证状态的一致性。
      * **区块根（Block Root）**
        * 区块的哈希根，表示区块的唯一标识。
      * **其他组件**
        * 包括验证者集合、随机数、投票信息等。
    * **功能**
      * 维护和更新Beacon链的状态，支持共识协议的运行。
    * **相关提案**
      * **EIP-4788: 在EVM中暴露Beacon状态根**
        * 提议在EVM中引入新的操作码，以获取Beacon链的状态根，支持智能合约验证Beacon链状态。 

### 2025.04.02
#### 23th-Cryptography/ecdsa
* **椭圆曲线数字签名算法（ECDSA）**
  * **简介**
    * ECDSA（Elliptic Curve Digital Signature Algorithm）是一种基于椭圆曲线密码学的数字签名算法。
    * 相较于传统的数字签名算法（如DSA），ECDSA在提供相同安全级别的情况下，使用更短的密钥长度，提高了效率。
    * 1985年，数学家Neal Koblitz和Victor S. Miller独立提出了将椭圆曲线应用于密码学的概念。
    * 1991年，NIST开发了DSA算法，随后Scott Vanstone提出了基于椭圆曲线的ECDSA算法。
    * 1998年至2000年间，ECDSA被多个标准化组织采纳为标准，包括ISO 14888-3、ANSI X9.62、IEEE 1363-2000和FIPS 186-2。
    * **椭圆曲线**
      * 定义在有限域上的椭圆曲线方程为：y² = x³ + ax + b，其中a, b ∈ F_q，且满足4a³ + 27b² ≠ 0，以确保曲线是非奇异的。
    * **有限域**
      * ECDSA通常使用素数阶有限域F_p，其中p为大素数。
    * **基点（G）**
      * 在椭圆曲线上选择一个基点G，其阶为大素数n，即nG = O，其中O是无穷远点。
  * **算法组成**
    * **参数生成**
      * 选择有限域F_q的阶q，以及表示方法FR。
      * 选择椭圆曲线参数a和b，确保曲线非奇异。
      * 计算曲线的阶N，选择一个大素数n，使得N能被n整除，并计算余因子h = N / n。
      * 选择基点G，使其阶为n。
    * **密钥生成**
      * 随机选择私钥d ∈ [1, n-1]。
      * 计算公钥Q = dG。
    * **签名生成**
      * 选择随机数k ∈ [1, n-1]。
      * 计算椭圆曲线点(kG)的x坐标x₁，令r = x₁ mod n。如果r = 0，重新选择k。
      * 计算消息m的哈希值e = H(m)。
      * 计算s = k⁻¹(e + dr) mod n。如果s = 0，重新选择k。
      * 签名为(r, s)。
    * **签名验证**
      * 检查r和s是否在区间[1, n-1]内。
      * 计算e = H(m)。
      * 计算w = s⁻¹ mod n。
      * 计算u₁ = ew mod n和u₂ = rw mod n。
      * 计算点X = u₁G + u₂Q，设X的x坐标为x₂。
      * 验证v = x₂ mod n是否等于r，若相等，则签名有效。
  * **安全性分析**
    * ECDSA的安全性基于椭圆曲线离散对数问题（ECDLP）的难解性。
    * 与传统的DSA相比，ECDSA在相同的安全级别下使用更短的密钥。例如，160位的ECDSA密钥提供与1024位RSA密钥相当的安全性。
  * **应用领域**
    * ECDSA广泛应用于需要数字签名的场景，如SSL/TLS协议、加密货币（如比特币）中的交易签名等。
  * **注意事项**
    * 随机数k的选择至关重要，重复或预测k可能导致私钥泄露。
    * 确保使用经过验证的椭圆曲线参数，以防范潜在的安全漏洞。

### 2025.04.02
#### 24th-Cryptography/BLS
* **BLS签名算法概述**

  *BLS签名算法* 是由斯坦福大学的Dan Boneh、Ben Lynn和Hovav Shacham于2001年提出的一种基于椭圆曲线密码学的数字签名方案。该算法以其短签名长度、快速验证和签名聚合等特性，在区块链、分布式系统和密码学领域得到了广泛应用。

* **BLS签名算法的基本组成**

  * **参数选择**

    - 选择一个大素数 $p$，定义三个循环群 $G_1$、$G_2$ 和 $G_T$，它们的阶为 $p$。
    - 定义一个双线性映射 $e: G_1 \times G_2 \rightarrow G_T$，满足以下性质：
      - **双线性性**：对于所有 $P \in G_1$，$Q \in G_2$ 和整数 $a, b$，有 $e(aP, bQ) = e(P, Q)^{ab}$。
      - **非退化性**：存在 $P \in G_1$ 和 $Q \in G_2$，使得 $e(P, Q) \neq 1$。
      - **可计算性**：对于所有 $P \in G_1$ 和 $Q \in G_2$，$e(P, Q)$ 可有效计算。

  * **密钥生成**

    - 随机选择一个整数 $x \in \mathbb{Z}_p^*$ 作为私钥 $SK$。
    - 计算公钥 $PK = x \cdot g_2$，其中 $g_2$ 是 $G_2$ 的生成元。

  * **签名生成**

    - 对消息 $M$ 进行哈希，得到 $h(M) \in G_1$。
    - 计算签名 $\sigma = x \cdot h(M)$。

  * **签名验证**

    - 验证等式 $e(\sigma, g_2) = e(h(M), PK)$ 是否成立。
    - 若等式成立，则签名有效；否则，签名无效。

* **BLS签名算法的特点**

  * **短签名长度**

    - BLS签名的长度仅为一个群元素的大小，通常为 48 字节（使用曲线 BLS12-381 时），远小于其他签名方案，如 ECDSA。

  * **快速验证**

    - 验证过程主要涉及双线性映射的计算，计算复杂度较低，适合需要快速签名验证的应用场景。

  * **签名聚合**

    - 多个签名可以聚合成一个签名，且聚合签名的大小与单个签名相同。
    - 验证聚合签名时，只需一次验证操作即可验证所有签名的有效性。

  * **确定性**

    - BLS签名过程不使用随机数，对同一消息和密钥对，签名是确定的。

* **BLS签名算法的应用**

  * **区块链验证**

    - 在区块链网络中，BLS签名算法允许节点快速验证多个交易或消息。
    - 由于签名的可聚合性，多个签名可以合并为一个，从而减少验证所需的时间和计算资源。

  * **分布式系统**

    - 在分布式系统中，BLS签名算法可以用于确保消息的完整性和真实性，同时减少通信开销。
    - 这对于需要高吞吐量和低延迟的应用尤为重要。

  * **物联网（IoT）**

    - 在物联网设备中，BLS签名算法可以用于高效地验证大量设备的消息，同时节省宝贵的计算资源和能量。

  * **匿名凭证系统**

    - 在需要保护用户隐私的应用中，BLS签名算法可以用于创建匿名凭证系统，允许用户向第三方证明其拥有某些属性，而无需泄露身份信息。

* **BLS签名算法的局限性**

  * **计算成本**

    - 虽然BLS签名验证过程相对高效，但双线性映射的计算仍比传统签名验证（如 ECDSA）更昂贵，尤其在硬件资源受限的设备上。

  * **恶意密钥攻击（Rogue Key Attack）**

    - 如果攻击者控制部分公钥，可能伪造签名。解决方法是要求签名者提供“公钥知识证明”（Proof of Possession）。

  * **依赖特定椭圆曲线**

    - BLS签名依赖支持配对的椭圆曲线（如 BLS12-381），这限制了其通用性。











<!-- Content_END -->
